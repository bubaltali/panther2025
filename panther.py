# -*- coding: utf-8 -*-
"""Untitled36.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Is5ZUBfSCeOEEmxnywO660r9cnBWCOc
"""

# -*- coding: utf-8 -*-
"""
PANTHER Challenge - Pancreatic Tumor Segmentation
Cell 0: Google Drive Setup Instructions and Verification

This notebook requires the PANTHER dataset in Google Drive
Please follow these setup instructions before running the main code
"""

print("ðŸ“‹ PANTHER CHALLENGE - GOOGLE COLAB SETUP GUIDE")
print("="*70)
print("ðŸŽ¯ This notebook requires the PANTHER dataset in Google Drive")
print("ðŸ“ Please follow these setup instructions before running the main code")
print("="*70)

print("\nðŸ“¤ STEP 1: UPLOAD PANTHER DATASET TO GOOGLE DRIVE")
print("-"*50)
print("1. Download the PANTHER dataset from the official source:")
print("   â€¢ Visit: https://www.synapse.org/#!Synapse:syn50714353")
print("   â€¢ Register and download PANTHER_Task1 dataset")
print("   â€¢ Extract the downloaded files")

print("\n2. Upload to Google Drive with this structure:")
print("   ðŸ“ MyDrive/")
print("   â””â”€â”€ ðŸ“ panther_dataset/")
print("       â””â”€â”€ ðŸ“ PANTHER_Task1/")
print("           â”œâ”€â”€ ðŸ“ ImagesTr/           (92 training images)")
print("           â”œâ”€â”€ ðŸ“ LabelsTr/           (92 training labels)")
print("           â”œâ”€â”€ ðŸ“ ImagesTs/           (48 test images)")
print("           â””â”€â”€ ðŸ“ ImagesTr_unlabeled/ (367 unlabeled images)")

print("\n3. Expected file formats:")
print("   â€¢ All files should be .mha format")
print("   â€¢ Images: 10000_0001_0000.mha, 10000_0002_0000.mha, etc.")
print("   â€¢ Labels: 10000_0001.mha, 10000_0002.mha, etc.")

print("\n" + "="*70)
print("ðŸ” STEP 2: VERIFY YOUR UPLOAD")
print("-"*50)

# Verification Code
import os

def verify_panther_setup():
    print("ðŸ” Verifying PANTHER dataset setup...")

    # Check for dataset directories
    dataset_paths = [
        "/content/drive/MyDrive/panther_dataset/PANTHER_Task1/ImagesTr",
        "/content/drive/MyDrive/panther_dataset/PANTHER_Task1/LabelsTr"
    ]

    all_good = True

    for path in dataset_paths:
        if os.path.exists(path):
            files = [f for f in os.listdir(path) if f.endswith('.mha')]
            print(f"âœ… {path}: {len(files)} .mha files")
        else:
            print(f"âŒ {path}: Not found")
            all_good = False

    if all_good:
        print("\nðŸŽ‰ Setup verification passed! Ready to run the main training code.")
    else:
        print("\nâš ï¸  Setup incomplete. Please upload the dataset first.")

    return all_good

# Run verification
verify_panther_setup()

print("\n" + "="*70)
print("ðŸš€ STEP 3: READY TO TRAIN")
print("-"*50)
print("Once your dataset is uploaded and verified:")
print("1. âœ… Run Cell 1: Environment Setup & Google Drive Mount")
print("2. âœ… Run Cell 2: Enhanced Imports and Device Setup")
print("3. âœ… Continue with remaining cells in sequence")
print("4. ðŸŽ¯ Target: Achieve 0.75+ Dice Score!")

print("\nðŸ’¡ TROUBLESHOOTING TIPS")
print("-"*30)
print("â€¢ If mounting fails: Restart runtime and try again")
print("â€¢ If dataset not found: Check folder names and structure")
print("â€¢ If out of memory: Reduce batch_size in Cell 3")
print("â€¢ If training is slow: Ensure GPU runtime is enabled")

print("\nðŸ”— USEFUL LINKS")
print("-"*20)
print("â€¢ PANTHER Dataset: https://www.synapse.org/#!Synapse:syn50714353")
print("â€¢ Google Colab GPU: https://colab.research.google.com/")
print("â€¢ PANTHER Paper: https://arxiv.org/abs/2312.06976")

print("\n" + "="*70)
print("âœ¨ Ready to start? Run the next cell to begin setup!")
print("="*70)

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 1: Environment Setup, Google Drive Mount, and Installations
import os
import sys
import warnings
warnings.filterwarnings('ignore')

# Memory optimization for PyTorch
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:128'
os.environ['CUDA_LAUNCH_BLOCKING'] = '1'

print("ðŸš€ IMPROVED PANTHER CHALLENGE - PANCREATIC SEGMENTATION")
print("ðŸŽ¯ Target: Achieve 0.75+ DSC with optimized architecture")
print("ðŸ’¾ Optimized for 15GB GPU with advanced memory management")
print("ðŸ”— Google Colab + Google Drive Integration")
print("="*70)

# Google Drive mounting for Google Colab
print("ðŸ“ Step 1: Mounting Google Drive...")
try:
    from google.colab import drive
    drive.mount('/content/drive', force_remount=True)
    print("âœ… Google Drive mounted successfully!")

    # Verify mount by checking if the drive folder exists
    if os.path.exists('/content/drive/MyDrive'):
        print("âœ… Google Drive MyDrive folder accessible")

        # List some contents to verify (optional)
        try:
            contents = os.listdir('/content/drive/MyDrive')[:5]  # Show first 5 items
            if contents:
                print(f"ðŸ“‹ MyDrive contents preview: {contents}")
            else:
                print("ðŸ“‹ MyDrive folder is empty")
        except Exception as e:
            print(f"âš ï¸  Could not list MyDrive contents: {e}")
    else:
        print("âŒ Google Drive mount failed - MyDrive folder not found")

except ImportError:
    print("âŒ Not running in Google Colab environment")
    print("âš ï¸  Please run this code in Google Colab for automatic drive mounting")
    print("ðŸ’¡ Alternative: Manually upload data or modify paths in Cell 3")
except Exception as e:
    print(f"âŒ Google Drive mounting failed: {e}")
    print("ðŸ’¡ Troubleshooting tips:")
    print("   â€¢ Make sure you're running in Google Colab")
    print("   â€¢ Grant permission when prompted")
    print("   â€¢ Check your Google Drive has sufficient space")
    print("   â€¢ Try running the cell again")

# Install required packages (run only if needed)
print("\nðŸ”§ Step 2: Installing required packages...")
def install_packages():
    """Install required packages if not already installed"""
    packages = [
        'torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118',
        'monai',
        'SimpleITK nibabel pydicom',
        'scipy scikit-image scikit-learn',
        'matplotlib seaborn tqdm',
        'tensorboard'
    ]

    for i, package in enumerate(packages, 1):
        try:
            print(f"   Installing package {i}/{len(packages)}: {package.split()[0]}...")
            os.system(f'pip install {package} --quiet')
        except Exception as e:
            print(f"   âš ï¸  Warning: Could not install {package}: {e}")

# Uncomment the next line to install packages (first time only)
install_packages()

# Verify critical packages
print("\nðŸ” Step 3: Verifying critical installations...")
try:
    import torch
    print(f"âœ… PyTorch: {torch.__version__}")
    print(f"âœ… CUDA available: {torch.cuda.is_available()}")
    if torch.cuda.is_available():
        print(f"âœ… CUDA version: {torch.version.cuda}")
        print(f"âœ… GPU name: {torch.cuda.get_device_name()}")
        print(f"âœ… GPU memory: {torch.cuda.get_device_properties(0).total_memory / 1e9:.1f} GB")
except ImportError:
    print("âŒ PyTorch not installed properly")

try:
    import SimpleITK as sitk
    print(f"âœ… SimpleITK: {sitk.Version.VersionString()}")
except ImportError:
    print("âŒ SimpleITK not installed properly")

try:
    import numpy as np
    import scipy
    import matplotlib.pyplot as plt
    print(f"âœ… NumPy: {np.__version__}")
    print(f"âœ… SciPy: {scipy.__version__}")
    print("âœ… Matplotlib: Available")
except ImportError as e:
    print(f"âŒ Scientific libraries not available: {e}")

# Check if PANTHER dataset is accessible
print("\nðŸ“Š Step 4: Checking PANTHER dataset accessibility...")
dataset_paths = [
    "/content/drive/MyDrive/panther_dataset",
    "/content/drive/MyDrive/PANTHER_dataset",
    "/content/drive/MyDrive/PANTHER",
    "/content/drive/MyDrive/panther"
]

dataset_found = False
found_path = None

for path in dataset_paths:
    if os.path.exists(path):
        dataset_found = True
        found_path = path
        print(f"âœ… PANTHER dataset found at: {path}")

        # Check for expected subdirectories
        expected_dirs = ["PANTHER_Task1", "Task1"]
        for subdir in expected_dirs:
            subdir_path = os.path.join(path, subdir)
            if os.path.exists(subdir_path):
                print(f"   âœ… Found task directory: {subdir}")

                # Check for data folders
                images_dir = os.path.join(subdir_path, "ImagesTr")
                labels_dir = os.path.join(subdir_path, "LabelsTr")

                if os.path.exists(images_dir):
                    img_count = len([f for f in os.listdir(images_dir) if f.endswith('.mha')])
                    print(f"      ðŸ“ Images: {img_count} .mha files")

                if os.path.exists(labels_dir):
                    lbl_count = len([f for f in os.listdir(labels_dir) if f.endswith('.mha')])
                    print(f"      ðŸ“ Labels: {lbl_count} .mha files")
        break

if not dataset_found:
    print("âŒ PANTHER dataset not found in expected locations")
    print("ðŸ’¡ Please ensure your dataset is uploaded to Google Drive in one of these locations:")
    for path in dataset_paths:
        print(f"   â€¢ {path}")
    print("\nðŸ“‹ Dataset should have this structure:")
    print("   panther_dataset/")
    print("   â””â”€â”€ PANTHER_Task1/")
    print("       â”œâ”€â”€ ImagesTr/          (training images .mha)")
    print("       â”œâ”€â”€ LabelsTr/          (training labels .mha)")
    print("       â””â”€â”€ ImagesTr_unlabeled/ (optional unlabeled data)")

print("\n" + "="*70)
if dataset_found:
    print("âœ… ENVIRONMENT SETUP COMPLETED SUCCESSFULLY!")
    print("ðŸš€ Ready to proceed with PANTHER Challenge training!")
    print(f"ðŸ“ Dataset location: {found_path}")
else:
    print("âš ï¸  ENVIRONMENT SETUP COMPLETED WITH WARNINGS")
    print("ðŸ“ Please upload PANTHER dataset before proceeding")

print("="*70)

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 2: Enhanced Imports and Device Setup
import gc
import json
import time
import random
import psutil
from pathlib import Path
from collections import defaultdict
from typing import Tuple, List, Optional, Dict, Any

# Core scientific libraries
import numpy as np
import pandas as pd
from scipy import ndimage
from scipy.ndimage import rotate, binary_opening, binary_closing
from sklearn.model_selection import KFold

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm.auto import tqdm

# Medical imaging
import SimpleITK as sitk

# PyTorch ecosystem
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader, WeightedRandomSampler
from torch.optim.lr_scheduler import CosineAnnealingWarmRestarts, ReduceLROnPlateau
from torch.cuda.amp import GradScaler, autocast

# File handling
from glob import glob

def set_seed(seed: int = 42) -> None:
    """Set random seeds for reproducibility"""
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

def setup_device() -> torch.device:
    """Setup and validate GPU device"""
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"âœ… Device: {device}")

    if torch.cuda.is_available():
        gpu_name = torch.cuda.get_device_name()
        total_memory = torch.cuda.get_device_properties(0).total_memory / 1e9
        print(f"ðŸ–¥ï¸  GPU: {gpu_name}")
        print(f"ðŸ’¾ Total GPU Memory: {total_memory:.1f} GB")

        # Clear GPU cache
        torch.cuda.empty_cache()
    else:
        print("âš ï¸  Running on CPU - training will be slow")

    return device

def cleanup_memory() -> None:
    """Enhanced memory cleanup"""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        torch.cuda.synchronize()
    gc.collect()

def get_memory_usage() -> str:
    """Get current memory usage"""
    if torch.cuda.is_available():
        gpu_mem = torch.cuda.memory_allocated() / 1e9
        gpu_cached = torch.cuda.memory_reserved() / 1e9
        return f"GPU: {gpu_mem:.2f}GB used, {gpu_cached:.2f}GB cached"

    ram_usage = psutil.virtual_memory().percent
    return f"RAM: {ram_usage:.1f}% used"

# Initialize
set_seed(42)
device = setup_device()

print(f"âœ… Enhanced imports completed")
print(f"ðŸ“Š Current memory: {get_memory_usage()}")

# Global constants for consistent paths
SAVE_DIR = "/content/drive/MyDrive/panther_models"
os.makedirs(SAVE_DIR, exist_ok=True)
print(f"ðŸ“ Model save directory: {SAVE_DIR}")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 3: Enhanced Configuration Class
from dataclasses import dataclass, field
from typing import Tuple, List

@dataclass
class PANTHERConfig:
    """Enhanced configuration for PANTHER Challenge"""

    # Model Architecture
    in_channels: int = 1
    out_channels: int = 1
    base_features: int = 32  # Increased from 24
    model_depth: int = 4
    use_attention: bool = True
    use_deep_supervision: bool = True
    dropout_rate: float = 0.1

    # Training Configuration
    patch_size: Tuple[int, int, int] = (96, 96, 96)  # Optimal size for context
    batch_size: int = 2
    validation_batch_size: int = 1
    num_epochs: int = 60
    learning_rate: float = 1e-4
    weight_decay: float = 1e-4

    # Advanced Training
    mixed_precision: bool = True
    gradient_clipping: float = 1.0
    warmup_epochs: int = 5
    scheduler_patience: int = 10
    early_stopping_patience: int = 20
    validation_interval: int = 2

    # Data Configuration
    train_ratio: float = 0.8
    validation_ratio: float = 0.2
    augmentation_probability: float = 0.8
    intensity_range: float = 0.15
    spatial_prob: float = 0.7

    # Loss Configuration
    dice_weight: float = 0.6
    focal_weight: float = 0.3
    boundary_weight: float = 0.1
    focal_alpha: float = 0.25
    focal_gamma: float = 2.0

    # Slice-wise Loss
    use_slice_weighted_loss: bool = True
    empty_slice_weight: float = 0.1
    tumor_slice_weight: float = 1.0

    # Memory Optimization
    chunk_size: int = 128
    chunk_overlap: int = 16
    num_workers: int = 2
    pin_memory: bool = True
    persistent_workers: bool = True

    # Paths
    data_root: str = "/content/drive/MyDrive/panther_dataset"
    task1_images_dir: str = field(init=False)
    task1_labels_dir: str = field(init=False)
    task1_unlabeled_dir: str = field(init=False)
    model_dir: str = "/content/drive/MyDrive/pansegnet_models_improved"

    def __post_init__(self):
        """Initialize derived paths and validate Google Drive setup"""

        # Auto-detect PANTHER dataset location
        self.data_root = self._find_dataset_root()

        # Set derived paths
        self.task1_images_dir = f"{self.data_root}/PANTHER_Task1/ImagesTr"
        self.task1_labels_dir = f"{self.data_root}/PANTHER_Task1/LabelsTr"
        self.task1_unlabeled_dir = f"{self.data_root}/PANTHER_Task1/ImagesTr_unlabeled"

        # Create model directory
        os.makedirs(self.model_dir, exist_ok=True)

        # Validate setup
        self._validate_config()
        self._validate_data_paths()

    def _find_dataset_root(self) -> str:
        """Auto-detect PANTHER dataset location in Google Drive"""

        possible_roots = [
            "/content/drive/MyDrive/panther_dataset",
            "/content/drive/MyDrive/PANTHER_dataset",
            "/content/drive/MyDrive/PANTHER",
            "/content/drive/MyDrive/panther",
            "/content/drive/MyDrive/PANTHER_Challenge",
            "/content/drive/MyDrive/Medical_Segmentation/panther_dataset"
        ]

        print("ðŸ” Auto-detecting PANTHER dataset location...")

        for root_path in possible_roots:
            if os.path.exists(root_path):
                # Check if it contains expected structure
                task1_path = os.path.join(root_path, "PANTHER_Task1")
                if os.path.exists(task1_path):
                    print(f"âœ… Dataset found: {root_path}")
                    return root_path

        # If not found, use default and warn user
        default_path = "/content/drive/MyDrive/panther_dataset"
        print(f"âš ï¸  Dataset not found, using default: {default_path}")
        print("ðŸ’¡ Please ensure your dataset is uploaded to Google Drive")

        return default_path

    def _validate_data_paths(self):
        """Validate that data paths exist and contain expected files"""

        print(f"\nðŸ“‚ Validating data paths...")

        # Check main directories
        paths_to_check = [
            ("Data root", self.data_root),
            ("Task 1 images", self.task1_images_dir),
            ("Task 1 labels", self.task1_labels_dir),
            ("Model directory", self.model_dir)
        ]

        validation_results = {"passed": 0, "warnings": 0, "errors": 0}

        for name, path in paths_to_check:
            if os.path.exists(path):
                print(f"   âœ… {name}: {path}")
                validation_results["passed"] += 1

                # Count files in data directories
                if "images" in name.lower() or "labels" in name.lower():
                    try:
                        mha_files = [f for f in os.listdir(path) if f.endswith('.mha')]
                        nii_files = [f for f in os.listdir(path) if f.endswith('.nii.gz')]
                        total_files = len(mha_files) + len(nii_files)

                        if total_files > 0:
                            print(f"      ðŸ“ Contains {len(mha_files)} .mha + {len(nii_files)} .nii.gz files")
                        else:
                            print(f"      âš ï¸  No medical image files found")
                            validation_results["warnings"] += 1
                    except Exception as e:
                        print(f"      âš ï¸  Could not count files: {e}")
                        validation_results["warnings"] += 1
            else:
                if "model" in name.lower():
                    print(f"   ðŸ“ {name}: {path} (will be created)")
                    validation_results["passed"] += 1
                else:
                    print(f"   âŒ {name}: {path} (not found)")
                    validation_results["errors"] += 1

        # Check unlabeled directory (optional)
        if os.path.exists(self.task1_unlabeled_dir):
            unlabeled_count = len([f for f in os.listdir(self.task1_unlabeled_dir)
                                 if f.endswith(('.mha', '.nii.gz'))])
            print(f"   âœ… Unlabeled data: {unlabeled_count} files (optional)")
        else:
            print(f"   âš ï¸  Unlabeled data: Not found (optional)")
            validation_results["warnings"] += 1

        # Summary
        print(f"\nðŸ“Š Path validation summary:")
        print(f"   âœ… Passed: {validation_results['passed']}")
        print(f"   âš ï¸  Warnings: {validation_results['warnings']}")
        print(f"   âŒ Errors: {validation_results['errors']}")

        if validation_results["errors"] > 0:
            print(f"\nðŸ’¡ Setup tips:")
            print(f"   â€¢ Ensure PANTHER dataset is uploaded to Google Drive")
            print(f"   â€¢ Check folder structure: panther_dataset/PANTHER_Task1/ImagesTr|LabelsTr")
            print(f"   â€¢ Verify file formats are .mha or .nii.gz")

        return validation_results["errors"] == 0

    def _validate_config(self):
        """Validate configuration parameters"""
        assert sum([self.dice_weight, self.focal_weight, self.boundary_weight]) <= 1.0, \
            "Loss weights must sum to <= 1.0"
        assert self.batch_size >= 1, "Batch size must be >= 1"
        assert all(p > 0 for p in self.patch_size), "Patch size must be positive"

        print(f"âœ… Configuration validated")

    def print_config(self):
        """Print configuration summary"""
        print(f"\nðŸ“‹ PANTHER Configuration Summary:")
        print(f"   Model: {self.base_features} features, depth {self.model_depth}")
        print(f"   Patch size: {self.patch_size}")
        print(f"   Batch size: {self.batch_size}")
        print(f"   Learning rate: {self.learning_rate}")
        print(f"   Mixed precision: {self.mixed_precision}")
        print(f"   Slice-weighted loss: {self.use_slice_weighted_loss}")
        print(f"   Data paths validated: {os.path.exists(self.task1_images_dir)}")

# Initialize configuration
config = PANTHERConfig()
config.print_config()

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 4: Enhanced Data Utilities
from pathlib import Path
from typing import List, Tuple, Optional
import json

class DataUtils:
    """Enhanced utilities for PANTHER dataset handling"""

    @staticmethod
    def find_medical_files(base_path: str, extensions: List[str] = ['.mha', '.nii.gz', '.nii']) -> Dict[str, List[str]]:
        """Find all medical imaging files recursively"""
        base_path = Path(base_path)
        found_files = defaultdict(list)

        for ext in extensions:
            pattern = f"**/*{ext}"
            files = list(base_path.glob(pattern))
            found_files[ext].extend([str(f) for f in files])

        return dict(found_files)

    @staticmethod
    def validate_file_pairs(image_files: List[str], label_files: List[str]) -> List[Tuple[str, str]]:
        """Enhanced file pair validation with better matching"""
        valid_pairs = []

        # Create mapping from image names to paths
        image_map = {}
        for img_path in image_files:
            img_name = Path(img_path).stem
            # Handle different naming conventions
            if '_0000' in img_name:
                # Task 1: 10000_0001_0000.mha -> 10000_0001
                base_name = '_'.join(img_name.split('_')[:2])
            else:
                # Task 2: 10303_0000.mha -> 10303
                base_name = img_name.split('_')[0]
            image_map[base_name] = img_path

        # Match with labels
        for label_path in label_files:
            label_name = Path(label_path).stem
            if label_name in image_map:
                valid_pairs.append((image_map[label_name], label_path))

        return valid_pairs

    @staticmethod
    def get_file_pairs(config: PANTHERConfig, task: int = 1) -> List[Tuple[str, str]]:
        """Get validated image-label pairs for specified task"""
        if task == 1:
            images_dir = config.task1_images_dir
            labels_dir = config.task1_labels_dir
            print(f"ðŸ“ Loading Task 1 data from:")
            print(f"   Images: {images_dir}")
            print(f"   Labels: {labels_dir}")
        else:
            raise ValueError(f"Task {task} not implemented")

        # Find files
        image_files = sorted(glob(os.path.join(images_dir, "*.mha")))
        label_files = sorted(glob(os.path.join(labels_dir, "*.mha")))

        print(f"ðŸ“Š Found {len(image_files)} image files")
        print(f"ðŸ“Š Found {len(label_files)} label files")

        # Validate pairs
        valid_pairs = DataUtils.validate_file_pairs(image_files, label_files)

        print(f"âœ… Validated {len(valid_pairs)} image-label pairs")

        if len(valid_pairs) == 0:
            print("âŒ No valid pairs found! Check file naming conventions.")
            return []

        # Show sample pairs
        print(f"\nðŸ“‹ Sample pairs:")
        for i, (img, lbl) in enumerate(valid_pairs[:3]):
            img_name = Path(img).name
            lbl_name = Path(lbl).name
            print(f"   {i+1}. {img_name} -> {lbl_name}")

        return valid_pairs

    @staticmethod
    def analyze_dataset_statistics(file_pairs: List[Tuple[str, str]], sample_size: int = 10) -> Dict[str, Any]:
        """Analyze dataset statistics for optimization"""
        print(f"\nðŸ“Š Analyzing dataset statistics (sample size: {sample_size})...")

        stats = {
            'image_shapes': [],
            'label_shapes': [],
            'tumor_volumes': [],
            'image_intensities': [],
            'spacing_info': []
        }

        sample_pairs = random.sample(file_pairs, min(sample_size, len(file_pairs)))

        for img_path, lbl_path in tqdm(sample_pairs, desc="Analyzing"):
            try:
                # Load images
                img_sitk = sitk.ReadImage(img_path)
                lbl_sitk = sitk.ReadImage(lbl_path)

                # Get arrays
                img_array = sitk.GetArrayFromImage(img_sitk)
                lbl_array = sitk.GetArrayFromImage(lbl_sitk)

                # Collect statistics
                stats['image_shapes'].append(img_array.shape)
                stats['label_shapes'].append(lbl_array.shape)

                # Tumor analysis
                tumor_mask = (lbl_array == 2)
                tumor_volume = tumor_mask.sum()
                total_volume = lbl_array.size
                tumor_ratio = tumor_volume / total_volume if total_volume > 0 else 0
                stats['tumor_volumes'].append(tumor_ratio)

                # Intensity analysis
                if img_array.size > 0:
                    stats['image_intensities'].append({
                        'min': float(img_array.min()),
                        'max': float(img_array.max()),
                        'mean': float(img_array.mean()),
                        'std': float(img_array.std())
                    })

                # Spacing information
                spacing = img_sitk.GetSpacing()
                stats['spacing_info'].append(spacing)

            except Exception as e:
                print(f"âš ï¸  Error analyzing {Path(img_path).name}: {e}")
                continue

        # Summary statistics
        if stats['image_shapes']:
            unique_shapes = list(set(stats['image_shapes']))
            avg_tumor_ratio = np.mean(stats['tumor_volumes'])

            print(f"\nðŸ“ˆ Dataset Statistics Summary:")
            print(f"   Unique image shapes: {len(unique_shapes)}")
            print(f"   Most common shape: {max(set(stats['image_shapes']), key=stats['image_shapes'].count)}")
            print(f"   Average tumor ratio: {avg_tumor_ratio:.4f} ({avg_tumor_ratio*100:.2f}%)")
            print(f"   Tumor volume range: {min(stats['tumor_volumes']):.4f} - {max(stats['tumor_volumes']):.4f}")

        return stats

# Test data utilities
print("ðŸ” Testing data utilities...")
file_pairs = DataUtils.get_file_pairs(config, task=1)

if len(file_pairs) > 0:
    # Analyze dataset
    dataset_stats = DataUtils.analyze_dataset_statistics(file_pairs, sample_size=5)
    print("âœ… Data utilities tested successfully")
else:
    print("âŒ No data found - check your data paths")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 5: Advanced Medical Augmentation
from typing import Tuple
import random
from scipy.ndimage import rotate, gaussian_filter, map_coordinates

class AdvancedMedicalAugmentation:
    """
    Advanced augmentation specifically designed for pancreatic tumor segmentation
    Based on medical imaging best practices and PANTHER dataset characteristics
    """

    def __init__(self,
                 intensity_range: float = 0.15,
                 spatial_prob: float = 0.7,
                 intensity_prob: float = 0.8,
                 preserve_tumor_prob: float = 0.9):
        self.intensity_range = intensity_range
        self.spatial_prob = spatial_prob
        self.intensity_prob = intensity_prob
        self.preserve_tumor_prob = preserve_tumor_prob

    def __call__(self, image: np.ndarray, label: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Apply augmentation pipeline"""

        # Check if there's tumor in the patch
        has_tumor = (label == 2).any()

        # Apply spatial augmentations
        if random.random() < self.spatial_prob:
            image, label = self._apply_spatial_augmentations(image, label, has_tumor)

        # Apply intensity augmentations
        if random.random() < self.intensity_prob:
            image = self._apply_intensity_augmentations(image)

        return image.astype(np.float32), label.astype(np.float32)

    def _apply_spatial_augmentations(self, image: np.ndarray, label: np.ndarray, has_tumor: bool) -> Tuple[np.ndarray, np.ndarray]:
        """Apply spatial augmentations with tumor preservation"""

        # Random flip (safe for all cases)
        if random.random() < 0.6:
            axes_to_flip = []
            for axis in [0, 1, 2]:
                if random.random() < 0.5:
                    axes_to_flip.append(axis)

            for axis in axes_to_flip:
                image = np.flip(image, axis=axis).copy()
                label = np.flip(label, axis=axis).copy()

        # Rotation (smaller angles for tumor preservation)
        if random.random() < 0.4:
            max_angle = 10 if has_tumor else 20  # Smaller rotation for tumor cases
            angle = random.uniform(-max_angle, max_angle)

            # Rotate around center
            image = rotate(image, angle, axes=(1, 2), reshape=False, order=1)
            label = rotate(label, angle, axes=(1, 2), reshape=False, order=0)

        # Elastic deformation (very conservative for medical data)
        if random.random() < 0.2 and not has_tumor:  # Skip for tumor cases
            image, label = self._elastic_deformation(image, label, alpha=5, sigma=2)

        # Scaling (minor)
        if random.random() < 0.3:
            scale_factor = random.uniform(0.95, 1.05)
            image, label = self._apply_scaling(image, label, scale_factor)

        return image, label

    def _apply_intensity_augmentations(self, image: np.ndarray) -> np.ndarray:
        """Apply intensity augmentations preserving medical characteristics"""

        # Only augment non-zero regions (preserve background)
        mask = image > 0
        if not mask.any():
            return image

        # Gaussian noise (very mild for medical data)
        if random.random() < 0.5:
            noise_std = random.uniform(0, 0.03)
            noise = np.random.normal(0, noise_std, image.shape)
            image = image + noise

        # Brightness adjustment
        if random.random() < 0.6:
            brightness = random.uniform(-self.intensity_range, self.intensity_range)
            image[mask] = image[mask] + brightness

        # Contrast adjustment
        if random.random() < 0.6:
            contrast = random.uniform(1-self.intensity_range, 1+self.intensity_range)
            mean_intensity = image[mask].mean()
            image[mask] = (image[mask] - mean_intensity) * contrast + mean_intensity

        # Gamma correction
        if random.random() < 0.3:
            gamma = random.uniform(0.8, 1.2)
            # Normalize to [0,1] for gamma correction
            img_min, img_max = image[mask].min(), image[mask].max()
            if img_max > img_min:
                image_norm = (image - img_min) / (img_max - img_min)
                image_norm = np.power(image_norm, gamma)
                image = image_norm * (img_max - img_min) + img_min

        # Gaussian blur (very mild)
        if random.random() < 0.2:
            sigma = random.uniform(0.3, 0.7)
            image = gaussian_filter(image, sigma=sigma)

        return image

    def _elastic_deformation(self, image: np.ndarray, label: np.ndarray,
                           alpha: float = 5, sigma: float = 2) -> Tuple[np.ndarray, np.ndarray]:
        """Apply mild elastic deformation"""
        shape = image.shape

        # Generate displacement fields
        dx = gaussian_filter((np.random.rand(*shape) * 2 - 1), sigma) * alpha
        dy = gaussian_filter((np.random.rand(*shape) * 2 - 1), sigma) * alpha
        dz = gaussian_filter((np.random.rand(*shape) * 2 - 1), sigma) * alpha

        # Create coordinate grids
        x, y, z = np.meshgrid(np.arange(shape[1]), np.arange(shape[0]), np.arange(shape[2]), indexing='ij')
        indices = [y + dy, x + dx, z + dz]

        # Apply deformation
        deformed_image = map_coordinates(image, indices, order=1, mode='reflect')
        deformed_label = map_coordinates(label, indices, order=0, mode='reflect')

        return deformed_image, deformed_label

    def _apply_scaling(self, image: np.ndarray, label: np.ndarray, scale: float) -> Tuple[np.ndarray, np.ndarray]:
        """Apply minor scaling with cropping/padding to maintain size"""
        from scipy.ndimage import zoom

        # Apply scaling
        scaled_image = zoom(image, scale, order=1)
        scaled_label = zoom(label, scale, order=0)

        # Maintain original size by cropping or padding
        target_shape = image.shape
        current_shape = scaled_image.shape

        # Calculate crop/pad for each dimension
        final_image = np.zeros(target_shape, dtype=image.dtype)
        final_label = np.zeros(target_shape, dtype=label.dtype)

        for i in range(3):
            if current_shape[i] >= target_shape[i]:
                # Crop
                start = (current_shape[i] - target_shape[i]) // 2
                end = start + target_shape[i]

                if i == 0:
                    scaled_image = scaled_image[start:end, :, :]
                    scaled_label = scaled_label[start:end, :, :]
                elif i == 1:
                    scaled_image = scaled_image[:, start:end, :]
                    scaled_label = scaled_label[:, start:end, :]
                else:
                    scaled_image = scaled_image[:, :, start:end]
                    scaled_label = scaled_label[:, :, start:end]
            else:
                # Pad will be handled by copying to zero arrays
                pass

        # Copy to final arrays (handles padding automatically)
        min_shape = [min(current_shape[i], target_shape[i]) for i in range(3)]
        final_image[:min_shape[0], :min_shape[1], :min_shape[2]] = \
            scaled_image[:min_shape[0], :min_shape[1], :min_shape[2]]
        final_label[:min_shape[0], :min_shape[1], :min_shape[2]] = \
            scaled_label[:min_shape[0], :min_shape[1], :min_shape[2]]

        return final_image, final_label

class MedicalAugmentationTester:
    """Test augmentation effects on sample data"""

    @staticmethod
    def test_augmentations(image: np.ndarray, label: np.ndarray, num_tests: int = 5):
        """Test augmentation pipeline"""
        augmenter = AdvancedMedicalAugmentation()

        print(f"ðŸ§ª Testing augmentations on {image.shape} image...")
        print(f"   Original tumor voxels: {(label == 2).sum()}")

        tumor_preservation = []

        for i in range(num_tests):
            aug_image, aug_label = augmenter(image.copy(), label.copy())

            original_tumor = (label == 2).sum()
            augmented_tumor = (aug_label == 2).sum()

            if original_tumor > 0:
                preservation_ratio = augmented_tumor / original_tumor
                tumor_preservation.append(preservation_ratio)

            print(f"   Test {i+1}: tumor voxels = {augmented_tumor} "
                  f"(preservation: {preservation_ratio:.3f})")

        if tumor_preservation:
            avg_preservation = np.mean(tumor_preservation)
            print(f"âœ… Average tumor preservation: {avg_preservation:.3f}")

            if avg_preservation > 0.95:
                print("ðŸŽ¯ Excellent tumor preservation!")
            elif avg_preservation > 0.90:
                print("ðŸ“ˆ Good tumor preservation")
            else:
                print("âš ï¸  Consider reducing augmentation intensity")

# Test augmentation if we have data
print("ðŸ§ª Setting up advanced medical augmentation...")
augmenter = AdvancedMedicalAugmentation()

# Test with synthetic data
test_image = np.random.randn(80, 80, 80).astype(np.float32)
test_label = np.zeros((80, 80, 80), dtype=np.float32)
test_label[30:50, 30:50, 30:50] = 2  # Add synthetic tumor

MedicalAugmentationTester.test_augmentations(test_image, test_label)
print("âœ… Advanced medical augmentation ready")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 6: Enhanced Dataset Class
from torch.utils.data import Dataset
import torch
from typing import Tuple, Optional, List
import SimpleITK as sitk

class EnhancedPancreaticDataset(Dataset):
    """
    Enhanced dataset for pancreatic tumor segmentation with:
    - Smart patch extraction based on tumor presence
    - Advanced preprocessing pipeline
    - Memory-efficient loading
    - Comprehensive data validation
    """

    def __init__(self,
                 image_paths: List[str],
                 label_paths: List[str],
                 config: PANTHERConfig,
                 mode: str = 'train',
                 transform: Optional[AdvancedMedicalAugmentation] = None):

        self.image_paths = image_paths
        self.label_paths = label_paths
        self.config = config
        self.mode = mode
        self.transform = transform
        self.patch_size = config.patch_size

        # Validate inputs
        assert len(image_paths) == len(label_paths), "Mismatch in image and label counts"
        assert mode in ['train', 'val', 'test'], f"Invalid mode: {mode}"

        # Pre-compute patch locations for training mode
        self.patch_locations = []
        if mode == 'train':
            self._compute_patch_locations()

        print(f"âœ… Dataset initialized: {len(self)} samples in {mode} mode")

    def _compute_patch_locations(self):
        """Compute smart patch locations based on tumor presence"""
        print("ðŸ” Computing intelligent patch locations...")

        for idx in tqdm(range(len(self.image_paths)), desc="Analyzing images"):
            try:
                # Load image and label to analyze tumor distribution
                img_sitk = sitk.ReadImage(self.image_paths[idx])
                lbl_sitk = sitk.ReadImage(self.label_paths[idx])

                img_shape = img_sitk.GetSize()[::-1]  # ITK uses (x,y,z), we need (z,y,x)
                lbl_array = sitk.GetArrayFromImage(lbl_sitk)

                # Find tumor regions
                tumor_mask = (lbl_array == 2)

                # Calculate patches per dimension
                patches_per_dim = []
                for i, (img_dim, patch_dim) in enumerate(zip(img_shape, self.patch_size)):
                    step_size = max(patch_dim // 2, patch_dim - self.config.chunk_overlap)
                    n_patches = max(1, (img_dim - patch_dim) // step_size + 1)
                    patches_per_dim.append(n_patches)

                # Generate patch locations with tumor-aware sampling
                tumor_patches = []
                background_patches = []

                for z in range(patches_per_dim[0]):
                    for y in range(patches_per_dim[1]):
                        for x in range(patches_per_dim[2]):
                            # Calculate patch boundaries
                            z_start = z * (self.patch_size[0] - self.config.chunk_overlap)
                            y_start = y * (self.patch_size[1] - self.config.chunk_overlap)
                            x_start = x * (self.patch_size[2] - self.config.chunk_overlap)

                            z_end = min(z_start + self.patch_size[0], img_shape[0])
                            y_end = min(y_start + self.patch_size[1], img_shape[1])
                            x_end = min(x_start + self.patch_size[2], img_shape[2])

                            # Check if patch contains tumor
                            patch_tumor = tumor_mask[z_start:z_end, y_start:y_end, x_start:x_end]

                            patch_info = (idx, z, y, x)

                            if patch_tumor.any():
                                tumor_patches.append(patch_info)
                            else:
                                background_patches.append(patch_info)

                # Balance tumor and background patches (favor tumor patches)
                # Keep all tumor patches and subsample background patches
                if tumor_patches:
                    # Keep all tumor patches
                    self.patch_locations.extend(tumor_patches)

                    # Add background patches (ratio 1:2 tumor:background)
                    n_background = min(len(background_patches), len(tumor_patches) * 2)
                    if n_background > 0:
                        sampled_background = random.sample(background_patches, n_background)
                        self.patch_locations.extend(sampled_background)
                else:
                    # No tumor in this image, keep some background patches
                    n_background = min(len(background_patches), 4)
                    if n_background > 0:
                        sampled_background = random.sample(background_patches, n_background)
                        self.patch_locations.extend(sampled_background)

            except Exception as e:
                print(f"âš ï¸  Error processing {self.image_paths[idx]}: {e}")
                continue

        print(f"âœ… Generated {len(self.patch_locations)} intelligent patch locations")

    def _normalize_intensity(self, image: np.ndarray) -> np.ndarray:
        """Advanced intensity normalization for pancreatic MRI"""
        # Remove background
        mask = image > 0
        if not mask.any():
            return image.astype(np.float32)

        # Robust percentile normalization (better than min-max)
        p1, p99 = np.percentile(image[mask], [1, 99])
        image = np.clip(image, p1, p99)

        # Z-score normalization on foreground only
        foreground_pixels = image[mask]
        mean_val = np.mean(foreground_pixels)
        std_val = np.std(foreground_pixels) + 1e-8

        image[mask] = (image[mask] - mean_val) / std_val

        return image.astype(np.float32)

    def _extract_patch(self, image: np.ndarray, label: np.ndarray,
                      patch_coords: Tuple[int, int, int]) -> Tuple[np.ndarray, np.ndarray]:
        """Extract patch with smart boundary handling"""
        z_start, y_start, x_start = patch_coords
        z_end = z_start + self.patch_size[0]
        y_end = y_start + self.patch_size[1]
        x_end = x_start + self.patch_size[2]

        img_shape = image.shape

        # Ensure we don't go out of bounds
        z_start_actual = max(0, z_start)
        y_start_actual = max(0, y_start)
        x_start_actual = max(0, x_start)
        z_end_actual = min(img_shape[0], z_end)
        y_end_actual = min(img_shape[1], y_end)
        x_end_actual = min(img_shape[2], x_end)

        # Extract actual patch
        img_patch = image[z_start_actual:z_end_actual,
                         y_start_actual:y_end_actual,
                         x_start_actual:x_end_actual]
        label_patch = label[z_start_actual:z_end_actual,
                           y_start_actual:y_end_actual,
                           x_start_actual:x_end_actual]

        # Pad if necessary to get exact patch size
        current_shape = img_patch.shape
        if current_shape != self.patch_size:
            pad_z = self.patch_size[0] - current_shape[0]
            pad_y = self.patch_size[1] - current_shape[1]
            pad_w = self.patch_size[2] - current_shape[2]

            # Pad with reflection for more natural boundaries
            img_patch = np.pad(img_patch,
                              ((0, pad_z), (0, pad_y), (0, pad_w)),
                              mode='reflect')
            label_patch = np.pad(label_patch,
                                ((0, pad_z), (0, pad_y), (0, pad_w)),
                                mode='constant',
                                constant_values=0)

        return img_patch, label_patch

    def _smart_crop_strategy(self, image: np.ndarray, label: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Smart cropping strategy for validation/test"""
        d, h, w = image.shape
        pd, ph, pw = self.patch_size

        # Find the center of mass of non-zero regions
        nonzero_coords = np.where(image > 0)
        if len(nonzero_coords[0]) > 0:
            center_z = int(np.mean(nonzero_coords[0]))
            center_y = int(np.mean(nonzero_coords[1]))
            center_x = int(np.mean(nonzero_coords[2]))
        else:
            center_z, center_y, center_x = d//2, h//2, w//2

        # Calculate crop boundaries around center
        start_z = max(0, center_z - pd//2)
        start_y = max(0, center_y - ph//2)
        start_x = max(0, center_x - pw//2)

        # Ensure we don't exceed image boundaries
        start_z = min(start_z, max(0, d - pd))
        start_y = min(start_y, max(0, h - ph))
        start_x = min(start_x, max(0, w - pw))

        return self._extract_patch(image, label, (start_z, start_y, start_x))

    def __len__(self) -> int:
        if self.mode == 'train':
            return len(self.patch_locations)
        else:
            return len(self.image_paths)

    def __getitem__(self, idx: int) -> Tuple[torch.Tensor, torch.Tensor, Optional[str]]:
        try:
            if self.mode == 'train':
                # Training mode: use pre-computed patch locations
                img_idx, z_patch, y_patch, x_patch = self.patch_locations[idx]

                # Load full image and label
                img_sitk = sitk.ReadImage(self.image_paths[img_idx])
                lbl_sitk = sitk.ReadImage(self.label_paths[img_idx])

                image = sitk.GetArrayFromImage(img_sitk).astype(np.float32)
                label = sitk.GetArrayFromImage(lbl_sitk).astype(np.float32)

                # Calculate patch coordinates
                z_start = z_patch * (self.patch_size[0] - self.config.chunk_overlap)
                y_start = y_patch * (self.patch_size[1] - self.config.chunk_overlap)
                x_start = x_patch * (self.patch_size[2] - self.config.chunk_overlap)

                # Extract patch
                image_patch, label_patch = self._extract_patch(
                    image, label, (z_start, y_start, x_start)
                )

                filepath = None

            else:
                # Validation/test mode: use full image with smart cropping
                img_sitk = sitk.ReadImage(self.image_paths[idx])
                lbl_sitk = sitk.ReadImage(self.label_paths[idx])

                image = sitk.GetArrayFromImage(img_sitk).astype(np.float32)
                label = sitk.GetArrayFromImage(lbl_sitk).astype(np.float32)

                # Smart cropping for validation
                image_patch, label_patch = self._smart_crop_strategy(image, label)

                filepath = self.image_paths[idx]

            # Normalize intensity
            image_patch = self._normalize_intensity(image_patch)

            # Create binary tumor mask (label 2 = tumor)
            tumor_mask = (label_patch == 2).astype(np.float32)

            # Apply augmentation if specified
            if self.transform and self.mode == 'train' and random.random() < self.config.augmentation_probability:
                image_patch, tumor_mask = self.transform(image_patch, tumor_mask)

            # Convert to tensors
            image_tensor = torch.from_numpy(image_patch).unsqueeze(0)  # Add channel dimension
            label_tensor = torch.from_numpy(tumor_mask).unsqueeze(0)   # Add channel dimension

            if self.mode == 'train':
                return image_tensor, label_tensor
            else:
                return image_tensor, label_tensor, filepath

        except Exception as e:
            print(f"âŒ Error loading sample {idx}: {e}")
            # Return a dummy sample to prevent training crashes
            dummy_image = torch.zeros(1, *self.patch_size)
            dummy_label = torch.zeros(1, *self.patch_size)

            if self.mode == 'train':
                return dummy_image, dummy_label
            else:
                return dummy_image, dummy_label, "error_sample"

# Data splitting utility
class DataSplitter:
    """Utility for creating train/validation splits"""

    @staticmethod
    def create_splits(file_pairs: List[Tuple[str, str]],
                     config: PANTHERConfig,
                     stratify_by_tumor: bool = True) -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]]]:
        """Create stratified train/validation splits"""

        print(f"ðŸ“Š Creating data splits...")
        print(f"   Total pairs: {len(file_pairs)}")
        print(f"   Train ratio: {config.train_ratio}")
        print(f"   Validation ratio: {config.validation_ratio}")

        if stratify_by_tumor and len(file_pairs) > 20:  # Only stratify if enough samples
            # Analyze tumor presence for stratification
            tumor_ratios = []

            for img_path, lbl_path in tqdm(file_pairs[:20], desc="Analyzing for stratification"):
                try:
                    lbl_sitk = sitk.ReadImage(lbl_path)
                    lbl_array = sitk.GetArrayFromImage(lbl_sitk)
                    tumor_ratio = (lbl_array == 2).sum() / lbl_array.size
                    tumor_ratios.append(tumor_ratio)
                except:
                    tumor_ratios.append(0.0)

            # Create stratification bins
            stratify_labels = ['low' if ratio < np.median(tumor_ratios) else 'high'
                             for ratio in tumor_ratios]

        # Shuffle and split
        random.shuffle(file_pairs)
        n_total = len(file_pairs)
        n_train = int(n_total * config.train_ratio)

        train_pairs = file_pairs[:n_train]
        val_pairs = file_pairs[n_train:]

        print(f"âœ… Data split created:")
        print(f"   Training samples: {len(train_pairs)}")
        print(f"   Validation samples: {len(val_pairs)}")

        return train_pairs, val_pairs

# Test dataset creation
print("ðŸ§ª Testing enhanced dataset...")

if len(file_pairs) > 0:
    # Create data splits
    train_pairs, val_pairs = DataSplitter.create_splits(file_pairs, config)

    # Create augmentation
    augmenter = AdvancedMedicalAugmentation(
        intensity_range=config.intensity_range,
        spatial_prob=config.spatial_prob
    )

    # Test dataset creation
    print("Creating test datasets...")
    train_images, train_labels = zip(*train_pairs[:5])  # Use subset for testing

    test_dataset = EnhancedPancreaticDataset(
        list(train_images), list(train_labels),
        config, mode='train', transform=augmenter
    )

    print(f"âœ… Enhanced dataset ready: {len(test_dataset)} samples")

    # Test data loading
    sample_data = test_dataset[0]
    print(f"âœ… Sample data shape: {sample_data[0].shape}, {sample_data[1].shape}")

else:
    print("âŒ No data available for testing dataset")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 7: Advanced U-Net Architecture with Attention and Deep Supervision
import torch
import torch.nn as nn
import torch.nn.functional as F
from typing import List, Tuple, Optional

class SE3DBlock(nn.Module):
    """Squeeze-and-Excitation block for 3D feature maps"""

    def __init__(self, channels: int, reduction: int = 16):
        super().__init__()
        self.squeeze = nn.AdaptiveAvgPool3d(1)
        self.excitation = nn.Sequential(
            nn.Linear(channels, channels // reduction, bias=False),
            nn.ReLU(inplace=True),
            nn.Linear(channels // reduction, channels, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        b, c, _, _, _ = x.size()
        y = self.squeeze(x).view(b, c)
        y = self.excitation(y).view(b, c, 1, 1, 1)
        return x * y.expand_as(x)

class ResidualBlock3D(nn.Module):
    """3D Residual block with optional SE attention"""

    def __init__(self, in_channels: int, out_channels: int,
                 stride: int = 1, use_se: bool = True, dropout_rate: float = 0.1):
        super().__init__()

        self.conv1 = nn.Conv3d(in_channels, out_channels, 3, stride, 1, bias=False)
        self.bn1 = nn.InstanceNorm3d(out_channels)
        self.conv2 = nn.Conv3d(out_channels, out_channels, 3, 1, 1, bias=False)
        self.bn2 = nn.InstanceNorm3d(out_channels)

        # SE block
        self.se = SE3DBlock(out_channels) if use_se else nn.Identity()

        # Dropout
        self.dropout = nn.Dropout3d(dropout_rate) if dropout_rate > 0 else nn.Identity()

        # Shortcut connection
        self.shortcut = nn.Sequential()
        if stride != 1 or in_channels != out_channels:
            self.shortcut = nn.Sequential(
                nn.Conv3d(in_channels, out_channels, 1, stride, bias=False),
                nn.InstanceNorm3d(out_channels)
            )

        self.activation = nn.LeakyReLU(0.01, inplace=True)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        residual = x

        out = self.activation(self.bn1(self.conv1(x)))
        out = self.bn2(self.conv2(out))
        out = self.se(out)
        out = self.dropout(out)

        out += self.shortcut(residual)
        out = self.activation(out)

        return out

class AttentionGate3D(nn.Module):
    """3D Attention Gate for skip connections"""

    def __init__(self, F_g: int, F_l: int, F_int: int):
        super().__init__()

        self.W_g = nn.Sequential(
            nn.Conv3d(F_g, F_int, kernel_size=1, stride=1, padding=0, bias=True),
            nn.InstanceNorm3d(F_int)
        )

        self.W_x = nn.Sequential(
            nn.Conv3d(F_l, F_int, kernel_size=1, stride=1, padding=0, bias=True),
            nn.InstanceNorm3d(F_int)
        )

        self.psi = nn.Sequential(
            nn.Conv3d(F_int, 1, kernel_size=1, stride=1, padding=0, bias=True),
            nn.InstanceNorm3d(1),
            nn.Sigmoid()
        )

        self.relu = nn.ReLU(inplace=True)

    def forward(self, g: torch.Tensor, x: torch.Tensor) -> torch.Tensor:
        # Ensure spatial dimensions match by upsampling g if needed
        if g.shape[2:] != x.shape[2:]:
            g = F.interpolate(g, size=x.shape[2:], mode='trilinear', align_corners=False)

        g1 = self.W_g(g)
        x1 = self.W_x(x)
        psi = self.relu(g1 + x1)
        psi = self.psi(psi)

        return x * psi

class AdvancedUNet3D(nn.Module):
    """
    Advanced 3D U-Net with:
    - Residual blocks with SE attention
    - Attention gates for skip connections
    - Deep supervision
    - Progressive feature enhancement
    """

    def __init__(self, config):
        super().__init__()

        self.config = config
        features = [config.base_features * (2**i) for i in range(config.model_depth + 1)]

        print(f"ðŸ—ï¸  Building Advanced U-Net with features: {features}")

        # Encoder
        self.encoder_blocks = nn.ModuleList()
        self.encoder_pools = nn.ModuleList()

        in_channels = config.in_channels
        for i, feature_count in enumerate(features[:-1]):
            # First block uses regular conv, others use residual
            if i == 0:
                block = nn.Sequential(
                    nn.Conv3d(in_channels, feature_count, 3, 1, 1, bias=False),
                    nn.InstanceNorm3d(feature_count),
                    nn.LeakyReLU(0.01, inplace=True),
                    nn.Conv3d(feature_count, feature_count, 3, 1, 1, bias=False),
                    nn.InstanceNorm3d(feature_count),
                    nn.LeakyReLU(0.01, inplace=True)
                )
            else:
                block = ResidualBlock3D(
                    in_channels, feature_count,
                    use_se=config.use_attention,
                    dropout_rate=config.dropout_rate
                )

            self.encoder_blocks.append(block)
            self.encoder_pools.append(nn.MaxPool3d(2, 2))
            in_channels = feature_count

        # Bottleneck
        self.bottleneck = nn.Sequential(
            ResidualBlock3D(
                features[-2], features[-1],
                use_se=config.use_attention,
                dropout_rate=config.dropout_rate * 2  # Higher dropout in bottleneck
            ),
            ResidualBlock3D(
                features[-1], features[-1],
                use_se=config.use_attention,
                dropout_rate=config.dropout_rate * 2
            )
        )

        # Decoder with attention gates
        self.decoder_upsamples = nn.ModuleList()
        self.attention_gates = nn.ModuleList()
        self.decoder_blocks = nn.ModuleList()

        reversed_features = features[::-1]  # [512, 256, 128, 64, 32]

        for i in range(len(reversed_features) - 1):
            in_feat = reversed_features[i]      # Current decoder level
            out_feat = reversed_features[i + 1] # Target decoder level

            # Upsampling: reduce channels from current level to target level
            self.decoder_upsamples.append(
                nn.ConvTranspose3d(in_feat, out_feat, kernel_size=2, stride=2)
            )

            # Attention gate
            if config.use_attention:
                self.attention_gates.append(
                    AttentionGate3D(F_g=out_feat, F_l=out_feat, F_int=out_feat // 2)
                )
            else:
                self.attention_gates.append(nn.Identity())

            # Decoder block: takes concatenated features
            self.decoder_blocks.append(
                ResidualBlock3D(
                    out_feat * 2, out_feat,  # Input: concat of upsampled + skip
                    use_se=config.use_attention,
                    dropout_rate=config.dropout_rate
                )
            )

        # Final output layer
        self.final_conv = nn.Conv3d(features[0], config.out_channels, kernel_size=1)

        # Deep supervision outputs
        if config.use_deep_supervision:
            decoder_channels = reversed_features[1:-1]  # Skip bottleneck and final level
            self.deep_supervision_outputs = nn.ModuleList([
                nn.Conv3d(channels, config.out_channels, kernel_size=1)
                for channels in decoder_channels
            ])

        # Initialize weights
        self._initialize_weights()

    def _initialize_weights(self):
        """Initialize network weights"""
        for m in self.modules():
            if isinstance(m, nn.Conv3d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='leaky_relu')
                if hasattr(m, 'bias') and m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            elif isinstance(m, (nn.InstanceNorm3d, nn.BatchNorm3d, nn.GroupNorm)):
                if hasattr(m, 'weight') and m.weight is not None:
                    nn.init.constant_(m.weight, 1)
                if hasattr(m, 'bias') and m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            elif isinstance(m, nn.ConvTranspose3d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='leaky_relu')
                if hasattr(m, 'bias') and m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            elif isinstance(m, nn.Linear):
                nn.init.xavier_normal_(m.weight)
                if hasattr(m, 'bias') and m.bias is not None:
                    nn.init.constant_(m.bias, 0)

    def forward(self, x: torch.Tensor):
        # Store input size for proper upsampling
        input_size = x.shape[2:]

        # Encoder
        encoder_features = []

        for i, (encoder_block, pool) in enumerate(zip(self.encoder_blocks, self.encoder_pools)):
            x = encoder_block(x)
            encoder_features.append(x)
            x = pool(x)

        # Bottleneck
        x = self.bottleneck(x)

        # Decoder
        deep_supervision_outputs = []

        for i, (upsample, attention_gate, decoder_block) in enumerate(
            zip(self.decoder_upsamples, self.attention_gates, self.decoder_blocks)
        ):
            # Upsample
            x = upsample(x)

            # Get corresponding encoder feature
            encoder_feat = encoder_features[-(i + 1)]

            # Ensure spatial dimensions match
            if x.shape[2:] != encoder_feat.shape[2:]:
                x = F.interpolate(x, size=encoder_feat.shape[2:],
                                mode='trilinear', align_corners=False)

            # Apply attention gate
            encoder_feat = attention_gate(x, encoder_feat)

            # Concatenate skip connection
            x = torch.cat([x, encoder_feat], dim=1)

            # Apply decoder block
            x = decoder_block(x)

            # Deep supervision output
            if self.config.use_deep_supervision and i < len(self.deep_supervision_outputs):
                deep_out = self.deep_supervision_outputs[i](x)
                # Resize to input size
                if deep_out.shape[2:] != input_size:
                    deep_out = F.interpolate(deep_out, size=input_size,
                                           mode='trilinear', align_corners=False)
                deep_supervision_outputs.append(deep_out)

        # Final output
        output = self.final_conv(x)

        # Ensure output matches input size
        if output.shape[2:] != input_size:
            output = F.interpolate(output, size=input_size,
                                 mode='trilinear', align_corners=False)

        if self.training and self.config.use_deep_supervision:
            return output, deep_supervision_outputs
        else:
            return output

class ModelFactory:
    """Factory for creating and managing models"""

    @staticmethod
    def create_model(config, device: torch.device) -> AdvancedUNet3D:
        """Create and initialize model"""
        try:
            print(f"ðŸ—ï¸  Creating model with config:")
            print(f"   Input channels: {config.in_channels}")
            print(f"   Output channels: {config.out_channels}")
            print(f"   Base features: {config.base_features}")
            print(f"   Model depth: {config.model_depth}")
            print(f"   Use attention: {config.use_attention}")
            print(f"   Use deep supervision: {config.use_deep_supervision}")

            model = AdvancedUNet3D(config)

            print(f"âœ… Model architecture created successfully")

            # Move to device
            model = model.to(device)
            print(f"âœ… Model moved to device: {device}")

            # Calculate model statistics
            total_params = sum(p.numel() for p in model.parameters())
            trainable_params = sum(p.numel() for p in model.parameters() if p.requires_grad)

            print(f"ðŸ§  Model Statistics:")
            print(f"   Total parameters: {total_params:,}")
            print(f"   Trainable parameters: {trainable_params:,}")
            print(f"   Model size: ~{total_params * 4 / 1e6:.1f} MB")

            return model

        except Exception as e:
            print(f"âŒ Model creation failed: {e}")
            import traceback
            traceback.print_exc()
            raise e

    @staticmethod
    def test_model(model: nn.Module, config, device: torch.device) -> bool:
        """Test model with dummy input"""
        try:
            print(f"ðŸ§ª Testing model with input shape: batch_size={config.batch_size}, channels={config.in_channels}, spatial={config.patch_size}")

            model.eval()

            # Create dummy input
            dummy_input = torch.randn(
                config.batch_size, config.in_channels, *config.patch_size,
                device=device, dtype=torch.float32
            )

            print(f"   Input tensor created: {dummy_input.shape}")

            # Forward pass
            with torch.no_grad():
                output = model(dummy_input)

                if isinstance(output, tuple):
                    main_output, deep_outputs = output
                    print(f"âœ… Main output shape: {main_output.shape}")
                    print(f"âœ… Deep supervision outputs: {len(deep_outputs)}")
                else:
                    print(f"âœ… Output shape: {output.shape}")

                # Check output values
                output_to_check = output[0] if isinstance(output, tuple) else output

                if torch.isnan(output_to_check).any():
                    print(f"âš ï¸  Warning: NaN values detected in output")
                    return False

                if torch.isinf(output_to_check).any():
                    print(f"âš ï¸  Warning: Inf values detected in output")
                    return False

                print(f"âœ… Output values are valid (no NaN/Inf)")
                print(f"   Output range: [{output_to_check.min():.4f}, {output_to_check.max():.4f}]")

            # Test training mode
            model.train()
            with torch.no_grad():
                output = model(dummy_input)
                print(f"âœ… Training mode test passed")

            print(f"âœ… Model test completed successfully!")
            return True

        except Exception as e:
            print(f"âŒ Model test failed: {e}")
            return False

# Create and test model
print("ðŸ—ï¸  Creating advanced U-Net model...")

# Create model
model = ModelFactory.create_model(config, device)

# Test model
test_success = ModelFactory.test_model(model, config, device)

if test_success:
    print("âœ… Advanced U-Net model ready for training!")
    cleanup_memory()
else:
    print("âŒ Model creation failed - check configuration")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 8: Advanced Loss Functions with Slice-Wise Weighting (Google Colab Optimized)
import torch
import torch.nn as nn
import torch.nn.functional as F
from typing import List, Optional, Tuple
import gc

print("ðŸ—ï¸ Loading Google Colab optimized loss functions...")

# Google Colab memory cleanup
def colab_memory_cleanup():
    """Colab-specific memory cleanup"""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        torch.cuda.synchronize()
    gc.collect()

class DiceLoss(nn.Module):
    """Differentiable Dice Loss for segmentation"""

    def __init__(self, smooth: float = 1e-6, apply_sigmoid: bool = True):
        super().__init__()
        self.smooth = smooth
        self.apply_sigmoid = apply_sigmoid

    def forward(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        if self.apply_sigmoid:
            pred = torch.sigmoid(pred)

        # Clamp predictions to prevent numerical issues
        pred = torch.clamp(pred, min=1e-7, max=1.0 - 1e-7)

        # Flatten tensors
        pred_flat = pred.view(pred.size(0), -1)
        target_flat = target.view(target.size(0), -1)

        # Calculate intersection and union
        intersection = (pred_flat * target_flat).sum(dim=1)
        union = pred_flat.sum(dim=1) + target_flat.sum(dim=1)

        # Calculate Dice coefficient
        dice = (2.0 * intersection + self.smooth) / (union + self.smooth)

        # Return Dice loss (1 - Dice coefficient)
        return 1 - dice.mean()

class FocalLoss(nn.Module):
    """Focal Loss for addressing class imbalance"""

    def __init__(self, alpha: float = 0.25, gamma: float = 2.0,
                 apply_sigmoid: bool = True, reduction: str = 'mean'):
        super().__init__()
        self.alpha = alpha
        self.gamma = gamma
        self.apply_sigmoid = apply_sigmoid
        self.reduction = reduction

    def forward(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        # Ensure target is in valid range [0, 1]
        target = torch.clamp(target, min=0.0, max=1.0)

        if self.apply_sigmoid:
            # Use BCE with logits for numerical stability
            ce_loss = F.binary_cross_entropy_with_logits(pred, target, reduction='none')
            pred_sigmoid = torch.sigmoid(pred)
        else:
            # Clamp predictions to prevent log(0) issues
            pred = torch.clamp(pred, min=1e-7, max=1.0 - 1e-7)
            ce_loss = F.binary_cross_entropy(pred, target, reduction='none')
            pred_sigmoid = pred

        # Calculate pt
        pt = torch.where(target == 1, pred_sigmoid, 1 - pred_sigmoid)
        # Clamp pt to prevent numerical issues
        pt = torch.clamp(pt, min=1e-7, max=1.0 - 1e-7)

        # Calculate focal weight
        focal_weight = self.alpha * (1 - pt) ** self.gamma

        # Apply focal weight
        focal_loss = focal_weight * ce_loss

        if self.reduction == 'mean':
            return focal_loss.mean()
        elif self.reduction == 'sum':
            return focal_loss.sum()
        else:
            return focal_loss

class BoundaryLoss(nn.Module):
    """Boundary-aware loss for better edge detection"""

    def __init__(self, apply_sigmoid: bool = True):
        super().__init__()
        self.apply_sigmoid = apply_sigmoid

    def forward(self, pred: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        if self.apply_sigmoid:
            pred = torch.sigmoid(pred)

        # Clamp predictions to prevent gradient issues
        pred = torch.clamp(pred, min=1e-7, max=1.0 - 1e-7)

        # Calculate 3D gradients using Sobel-like operators
        pred_grad = self._calculate_3d_gradient(pred)
        target_grad = self._calculate_3d_gradient(target)

        # L2 loss on gradients
        boundary_loss = F.mse_loss(pred_grad, target_grad)

        return boundary_loss

    def _calculate_3d_gradient(self, x: torch.Tensor) -> torch.Tensor:
        """Calculate 3D gradient magnitude"""
        # Handle edge cases for small tensors
        if x.size(2) <= 1 or x.size(3) <= 1 or x.size(4) <= 1:
            return torch.zeros_like(x)

        # Sobel kernels for 3D gradient
        grad_z = torch.abs(x[:, :, 1:, :, :] - x[:, :, :-1, :, :])
        grad_y = torch.abs(x[:, :, :, 1:, :] - x[:, :, :, :-1, :])
        grad_x = torch.abs(x[:, :, :, :, 1:] - x[:, :, :, :, :-1])

        # Pad to original size
        grad_z = F.pad(grad_z, (0, 0, 0, 0, 0, 1))
        grad_y = F.pad(grad_y, (0, 0, 0, 1, 0, 0))
        grad_x = F.pad(grad_x, (0, 1, 0, 0, 0, 0))

        # Combine gradients
        gradient_magnitude = torch.sqrt(grad_z**2 + grad_y**2 + grad_x**2 + 1e-8)

        return gradient_magnitude

class SliceWiseWeightedLoss(nn.Module):
    """
    Google Colab Optimized Slice-Wise Weighted Loss
    Uses CPU-GPU hybrid approach for stability
    """

    def __init__(self,
                 dice_weight: float = 0.6,
                 focal_weight: float = 0.3,
                 boundary_weight: float = 0.1,
                 empty_slice_weight: float = 0.1,
                 tumor_slice_weight: float = 1.0,
                 focal_alpha: float = 0.25,
                 focal_gamma: float = 2.0):
        super().__init__()

        self.dice_weight = dice_weight
        self.focal_weight = focal_weight
        self.boundary_weight = boundary_weight
        self.empty_slice_weight = empty_slice_weight
        self.tumor_slice_weight = tumor_slice_weight

        # Create loss components
        self.dice_loss = DiceLoss()
        self.focal_loss = FocalLoss(alpha=focal_alpha, gamma=focal_gamma)
        self.boundary_loss = BoundaryLoss()

        print(f"ðŸŽ¯ Slice-wise weighted loss initialized:")
        print(f"   Dice weight: {dice_weight}")
        print(f"   Focal weight: {focal_weight}")
        print(f"   Boundary weight: {boundary_weight}")
        print(f"   Tumor slice weight: {tumor_slice_weight}")

    def forward(self, pred: torch.Tensor, target: torch.Tensor,
                deep_outputs: Optional[List[torch.Tensor]] = None) -> torch.Tensor:

        # Calculate tumor weighting
        tumor_ratio = target.sum() / target.numel()
        if tumor_ratio > 0.01:
            loss_weight = self.tumor_slice_weight
        else:
            loss_weight = self.empty_slice_weight

        # Main loss components
        dice = self.dice_loss(pred, target)
        focal = self.focal_loss(pred, target)
        boundary = self.boundary_loss(pred, target)

        # Combine main losses
        main_loss = (self.dice_weight * dice +
                    self.focal_weight * focal +
                    self.boundary_weight * boundary)

        # Apply slice weighting
        weighted_loss = main_loss * loss_weight

        # Add deep supervision if available
        if deep_outputs is not None:
            deep_loss = 0.0
            deep_weight = 0.5

            for i, deep_output in enumerate(deep_outputs):
                if torch.isnan(deep_output).any() or torch.isinf(deep_output).any():
                    continue

                try:
                    if deep_output.shape != target.shape:
                        target_resized = F.interpolate(
                            target, size=deep_output.shape[2:],
                            mode='trilinear', align_corners=False
                        )
                    else:
                        target_resized = target

                    # Simple Dice loss for deep supervision
                    deep_dice = self.dice_loss(deep_output, target_resized)
                    deep_loss += deep_dice * (0.5 ** i)

                except Exception as e:
                    print(f"âš ï¸  Deep supervision level {i} failed: {e}")
                    continue

            weighted_loss += deep_weight * deep_loss

        return weighted_loss

class LossFactory:
    """Factory for creating loss functions"""

    @staticmethod
    def create_loss(config) -> nn.Module:
        """Create loss function based on configuration"""

        if hasattr(config, 'use_slice_weighted_loss') and config.use_slice_weighted_loss:
            print("ðŸŽ¯ Creating slice-wise weighted loss...")
            loss_fn = SliceWiseWeightedLoss(
                dice_weight=getattr(config, 'dice_weight', 0.6),
                focal_weight=getattr(config, 'focal_weight', 0.3),
                boundary_weight=getattr(config, 'boundary_weight', 0.1),
                empty_slice_weight=getattr(config, 'empty_slice_weight', 0.1),
                tumor_slice_weight=getattr(config, 'tumor_slice_weight', 1.0),
                focal_alpha=getattr(config, 'focal_alpha', 0.25),
                focal_gamma=getattr(config, 'focal_gamma', 2.0)
            )
        else:
            print("ðŸŽ¯ Creating standard combined loss...")
            # Standard combined loss without slice weighting
            class StandardCombinedLoss(nn.Module):
                def __init__(self, config):
                    super().__init__()
                    self.dice_loss = DiceLoss()
                    self.focal_loss = FocalLoss(
                        alpha=getattr(config, 'focal_alpha', 0.25),
                        gamma=getattr(config, 'focal_gamma', 2.0)
                    )
                    self.boundary_loss = BoundaryLoss()
                    self.dice_weight = getattr(config, 'dice_weight', 0.6)
                    self.focal_weight = getattr(config, 'focal_weight', 0.3)
                    self.boundary_weight = getattr(config, 'boundary_weight', 0.1)

                def forward(self, pred, target, deep_outputs=None):
                    # Validate inputs
                    pred = torch.clamp(pred, min=-10.0, max=10.0)
                    target = torch.clamp(target, min=0.0, max=1.0)

                    dice = self.dice_loss(pred, target)
                    focal = self.focal_loss(pred, target)
                    boundary = self.boundary_loss(pred, target)

                    main_loss = (self.dice_weight * dice +
                               self.focal_weight * focal +
                               self.boundary_weight * boundary)

                    if deep_outputs is not None:
                        deep_loss = 0.0
                        for i, deep_out in enumerate(deep_outputs):
                            if torch.isnan(deep_out).any() or torch.isinf(deep_out).any():
                                continue

                            if deep_out.shape != target.shape:
                                target_resized = F.interpolate(
                                    target, size=deep_out.shape[2:],
                                    mode='trilinear', align_corners=False
                                )
                            else:
                                target_resized = target

                            target_resized = torch.clamp(target_resized, min=0.0, max=1.0)
                            deep_dice = DiceLoss()(deep_out, target_resized)
                            deep_loss += deep_dice * (0.5 ** i)

                        main_loss += 0.5 * deep_loss

                    return main_loss

            loss_fn = StandardCombinedLoss(config)

        return loss_fn

    @staticmethod
    def test_loss_function(loss_fn: nn.Module, config, device: torch.device):
        """Test loss function"""
        print("ðŸ§ª Testing loss function...")

        try:
            # Force memory cleanup first
            colab_memory_cleanup()

            batch_size = 1
            out_channels = getattr(config, 'out_channels', 1)
            test_patch_size = (32, 32, 32)  # Small for testing

            # Create test data
            pred = torch.randn(batch_size, out_channels, *test_patch_size,
                             dtype=torch.float32, requires_grad=True, device=device)
            target = torch.zeros(batch_size, out_channels, *test_patch_size,
                               dtype=torch.float32, device=device)
            target[:, :, 10:20, 10:20, 10:20] = 1.0  # Small tumor region

            # Test loss
            loss = loss_fn(pred, target)
            print(f"âœ… Loss computed: {loss.item():.4f}")

            # Test backward pass
            loss.backward()
            print(f"âœ… Backward pass successful")

            # Check gradients
            has_gradients = pred.grad is not None and pred.grad.sum().item() != 0
            print(f"âœ… Gradients computed: {has_gradients}")

            colab_memory_cleanup()
            return True

        except Exception as e:
            print(f"âŒ Loss function test failed: {e}")
            import traceback
            traceback.print_exc()
            return False

# Create and test loss function
print("ðŸŽ¯ Creating loss function...")

# Clean memory first
colab_memory_cleanup()

# Create loss function
criterion = LossFactory.create_loss(config)

# Test loss function
test_success = LossFactory.test_loss_function(criterion, config, device)

if test_success:
    print("âœ… Loss function ready!")
    colab_memory_cleanup()
else:
    print("âŒ Loss function creation failed")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 9: Data Preparation and Training Setup
from torch.utils.data import DataLoader
import torch.optim as optim
from torch.optim.lr_scheduler import ReduceLROnPlateau

print("ðŸ“Š Setting up data preparation and training components...")

# Create data splits if we have file pairs
if 'file_pairs' in globals() and len(file_pairs) > 0:
    # Create data splits
    train_pairs, val_pairs = DataSplitter.create_splits(file_pairs, config)

    # Extract paths
    train_images, train_labels = zip(*train_pairs)
    val_images, val_labels = zip(*val_pairs)

    # Create augmentation
    augmenter = AdvancedMedicalAugmentation(
        intensity_range=config.intensity_range,
        spatial_prob=config.spatial_prob
    )

    print("ðŸ”§ Creating datasets...")

    # Create datasets with validation-style extraction for both train and val
    # This ensures consistent tumor-rich sampling
    train_dataset = EnhancedPancreaticDataset(
        list(train_images),
        list(train_labels),
        config,
        mode='val',  # Use val mode for consistent cropping
        transform=augmenter
    )

    val_dataset = EnhancedPancreaticDataset(
        list(val_images),
        list(val_labels),
        config,
        mode='val',  # Validation mode
        transform=None  # No augmentation for validation
    )

    # Create data loaders
    train_loader = DataLoader(
        train_dataset,
        batch_size=config.batch_size,
        shuffle=True,
        num_workers=config.num_workers,
        pin_memory=config.pin_memory,
        drop_last=True,
        persistent_workers=config.persistent_workers
    )

    val_loader = DataLoader(
        val_dataset,
        batch_size=config.validation_batch_size,
        shuffle=False,
        num_workers=config.num_workers,
        pin_memory=config.pin_memory,
        drop_last=False,
        persistent_workers=config.persistent_workers
    )

    print(f"âœ… Data loaders created:")
    print(f"   Training batches: {len(train_loader)}")
    print(f"   Validation batches: {len(val_loader)}")

    # Test data loading
    print("ðŸ§ª Testing data loaders...")
    try:
        train_batch = next(iter(train_loader))
        val_batch = next(iter(val_loader))

        if len(train_batch) == 3:
            train_images_batch, train_masks_batch, _ = train_batch
        else:
            train_images_batch, train_masks_batch = train_batch

        if len(val_batch) == 3:
            val_images_batch, val_masks_batch, _ = val_batch
        else:
            val_images_batch, val_masks_batch = val_batch

        print(f"âœ… Train batch: {train_images_batch.shape}, {train_masks_batch.shape}")
        print(f"âœ… Val batch: {val_images_batch.shape}, {val_masks_batch.shape}")
        print(f"   Train tumor voxels: {(train_masks_batch > 0.5).sum().item()}")
        print(f"   Val tumor voxels: {(val_masks_batch > 0.5).sum().item()}")

        data_loading_success = True

    except Exception as e:
        print(f"âŒ Data loading test failed: {e}")
        data_loading_success = False

else:
    print("âŒ No file pairs available - check dataset setup")
    data_loading_success = False

# Setup optimizer and scheduler
if data_loading_success:
    print("\nðŸ”§ Setting up optimizer and scheduler...")

    # Optimizer - AdamW with weight decay
    optimizer = optim.AdamW(
        model.parameters(),
        lr=config.learning_rate,
        weight_decay=config.weight_decay,
        betas=(0.9, 0.999),
        eps=1e-8
    )

    # Learning rate scheduler
    scheduler = ReduceLROnPlateau(
        optimizer,
        mode='max',  # Monitor validation Dice (higher is better)
        factor=0.5,
        patience=config.scheduler_patience,
        verbose=True,
        min_lr=1e-7
    )

    print(f"âœ… Optimizer: AdamW (lr={config.learning_rate}, wd={config.weight_decay})")
    print(f"âœ… Scheduler: ReduceLROnPlateau (patience={config.scheduler_patience})")

    # Mixed precision scaler (if enabled)
    if config.mixed_precision:
        scaler = torch.cuda.amp.GradScaler()
        print(f"âœ… Mixed precision enabled")
    else:
        scaler = None
        print(f"ðŸ“‹ Mixed precision disabled")

# Training and validation functions
def calculate_dice_score(pred: torch.Tensor, target: torch.Tensor, threshold: float = 0.5) -> float:
    """Calculate Dice score"""
    pred_binary = (torch.sigmoid(pred) > threshold).float()

    intersection = (pred_binary * target).sum()
    union = pred_binary.sum() + target.sum()

    if union == 0:
        return 1.0  # Perfect score if both are empty

    dice = (2.0 * intersection) / union
    return dice.item()

def train_epoch_stable():
    """Stable training epoch function"""
    model.train()

    total_loss = 0
    total_dice = 0
    valid_batches = 0

    # Ensure model parameters require gradients
    for param in model.parameters():
        param.requires_grad = True

    for batch_idx, batch_data in enumerate(tqdm(train_loader, desc="Training")):
        try:
            # Handle batch format
            if len(batch_data) == 3:
                images, masks, _ = batch_data
            else:
                images, masks = batch_data

            # Move to device
            images = images.to(device, dtype=torch.float32)
            masks = masks.to(device, dtype=torch.float32)

            # Skip batch if no tumor content (optional)
            if masks.sum() == 0 and batch_idx % 3 != 0:  # Keep some empty batches
                continue

            # Zero gradients
            optimizer.zero_grad()

            # Forward pass with mixed precision
            if config.mixed_precision and scaler is not None:
                with torch.cuda.amp.autocast():
                    outputs = model(images)

                    if isinstance(outputs, tuple):
                        main_output, deep_outputs = outputs
                        loss = criterion(main_output, masks, deep_outputs)
                    else:
                        loss = criterion(outputs, masks)

                # Backward pass with scaling
                scaler.scale(loss).backward()

                # Gradient clipping
                scaler.unscale_(optimizer)
                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=config.gradient_clipping)

                # Optimizer step
                scaler.step(optimizer)
                scaler.update()

            else:
                # Standard precision training
                outputs = model(images)

                if isinstance(outputs, tuple):
                    main_output, deep_outputs = outputs
                    loss = criterion(main_output, masks, deep_outputs)
                else:
                    main_output = outputs
                    loss = criterion(outputs, masks)

                # Backward pass
                loss.backward()

                # Gradient clipping
                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=config.gradient_clipping)

                # Optimizer step
                optimizer.step()

            # Calculate metrics
            with torch.no_grad():
                dice = calculate_dice_score(main_output, masks)

            # Accumulate metrics
            total_loss += loss.item()
            total_dice += dice
            valid_batches += 1

            # Memory cleanup every 10 batches
            if batch_idx % 10 == 0:
                cleanup_memory()

        except Exception as e:
            print(f"âš ï¸  Error in batch {batch_idx}: {e}")
            continue

    if valid_batches == 0:
        return 0.0, 0.0

    avg_loss = total_loss / valid_batches
    avg_dice = total_dice / valid_batches

    return avg_loss, avg_dice

def validate_epoch_stable():
    """Stable validation epoch function"""
    model.eval()

    total_loss = 0
    total_dice = 0
    valid_batches = 0

    with torch.no_grad():
        for batch_idx, batch_data in enumerate(tqdm(val_loader, desc="Validation")):
            try:
                # Handle batch format
                if len(batch_data) == 3:
                    images, masks, _ = batch_data
                else:
                    images, masks = batch_data

                # Move to device
                images = images.to(device, dtype=torch.float32)
                masks = masks.to(device, dtype=torch.float32)

                # Forward pass
                outputs = model(images)

                if isinstance(outputs, tuple):
                    main_output = outputs[0]
                else:
                    main_output = outputs

                # Calculate loss
                loss = criterion(main_output, masks)

                # Calculate Dice score
                dice = calculate_dice_score(main_output, masks)

                total_loss += loss.item()
                total_dice += dice
                valid_batches += 1

            except Exception as e:
                print(f"âš ï¸  Error in validation batch {batch_idx}: {e}")
                continue

    if valid_batches == 0:
        return 0.0, 0.0

    avg_loss = total_loss / valid_batches
    avg_dice = total_dice / valid_batches

    return avg_loss, avg_dice

# Final setup validation
if data_loading_success:
    print("\nðŸŽ¯ PANTHER Training Setup Complete!")
    print("="*50)
    print(f"âœ… Model: Advanced U-Net 3D")
    print(f"âœ… Loss: Slice-wise weighted loss")
    print(f"âœ… Optimizer: AdamW")
    print(f"âœ… Scheduler: ReduceLROnPlateau")
    print(f"âœ… Data: {len(train_pairs)} train, {len(val_pairs)} val")
    print(f"âœ… Target: 0.75+ Dice Score for PANTHER Challenge")
    print("="*50)
    print("ðŸš€ Ready to start training!")

else:
    print("\nâŒ Setup incomplete - check data loading errors")
    print("ðŸ’¡ Ensure PANTHER dataset is properly uploaded to Google Drive")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Cell 10: Main Training Loop with Real-time Monitoring
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
import time

print("ðŸš€ Starting PANTHER Challenge Training Loop")
print("="*60)

# Training configuration
NUM_EPOCHS = 50
BEST_DICE_THRESHOLD = 0.75  # PANTHER Challenge target
EARLY_STOPPING_PATIENCE = 15

# Initialize tracking variables
best_dice = 0.0
best_epoch = 0
patience_counter = 0
training_history = {
    'train_loss': [],
    'train_dice': [],
    'val_loss': [],
    'val_dice': [],
    'learning_rates': [],
    'epochs': []
}

# Ensure training setup is complete
if not data_loading_success:
    print("âŒ Cannot start training - data loading failed")
    print("ðŸ’¡ Please run previous cells to fix data loading issues")
else:
    print(f"ðŸŽ¯ Training Configuration:")
    print(f"   Epochs: {NUM_EPOCHS}")
    print(f"   Target Dice: {BEST_DICE_THRESHOLD}")
    print(f"   Early stopping patience: {EARLY_STOPPING_PATIENCE}")
    print(f"   Mixed precision: {config.mixed_precision}")
    print("="*60)

    # Start training
    training_start_time = time.time()

    try:
        for epoch in range(NUM_EPOCHS):
            epoch_start_time = time.time()

            print(f"\nðŸ“Š Epoch {epoch+1}/{NUM_EPOCHS}")
            print("-" * 40)

            # Training phase
            train_loss, train_dice = train_epoch_stable()

            # Validation phase
            val_loss, val_dice = validate_epoch_stable()

            # Get current learning rate
            current_lr = optimizer.param_groups[0]['lr']

            # Calculate epoch time
            epoch_time = time.time() - epoch_start_time

            # Update history
            training_history['train_loss'].append(train_loss)
            training_history['train_dice'].append(train_dice)
            training_history['val_loss'].append(val_loss)
            training_history['val_dice'].append(val_dice)
            training_history['learning_rates'].append(current_lr)
            training_history['epochs'].append(epoch + 1)

            # Print epoch results
            print(f"   ðŸ“ˆ Train - Loss: {train_loss:.4f}, Dice: {train_dice:.4f}")
            print(f"   ðŸ“Š Val   - Loss: {val_loss:.4f}, Dice: {val_dice:.4f}")
            print(f"   â±ï¸  Time: {epoch_time:.1f}s, LR: {current_lr:.2e}")

            # Check for improvement
            if val_dice > best_dice:
                best_dice = val_dice
                best_epoch = epoch + 1
                patience_counter = 0

                # Save best model
                checkpoint = {
                    'epoch': epoch,
                    'model_state_dict': model.state_dict(),
                    'optimizer_state_dict': optimizer.state_dict(),
                    'scheduler_state_dict': scheduler.state_dict(),
                    'best_dice': best_dice,
                    'training_history': training_history,
                    'config': config.__dict__ if hasattr(config, '__dict__') else str(config)
                }

                best_model_path = f"{SAVE_DIR}/best_panther_model.pth"
                torch.save(checkpoint, best_model_path)

                print(f"   ðŸŽ‰ NEW BEST MODEL! Dice: {val_dice:.4f} (saved)")

                # Check if PANTHER target achieved
                if val_dice >= BEST_DICE_THRESHOLD:
                    print(f"\nðŸ†ðŸ†ðŸ† PANTHER CHALLENGE TARGET ACHIEVED! ðŸ†ðŸ†ðŸ†")
                    print(f"ðŸŽ¯ FINAL SCORE: {val_dice:.4f}")
                    print(f"ðŸ Training completed successfully in {epoch+1} epochs!")
                    break

            else:
                patience_counter += 1
                print(f"   ðŸ“‰ No improvement (patience: {patience_counter}/{EARLY_STOPPING_PATIENCE})")

            # Update learning rate scheduler
            scheduler.step(val_dice)

            # Real-time visualization every 5 epochs
            if (epoch + 1) % 5 == 0 or epoch == 0:
                clear_output(wait=True)

                # Create training progress plot
                fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))

                epochs_list = training_history['epochs']

                # Loss curves
                ax1.plot(epochs_list, training_history['train_loss'], 'b-', label='Train Loss', linewidth=2)
                ax1.plot(epochs_list, training_history['val_loss'], 'r-', label='Val Loss', linewidth=2)
                ax1.set_xlabel('Epoch')
                ax1.set_ylabel('Loss')
                ax1.set_title('Training and Validation Loss')
                ax1.legend()
                ax1.grid(True, alpha=0.3)

                # Dice score curves
                ax2.plot(epochs_list, training_history['train_dice'], 'b-', label='Train Dice', linewidth=2)
                ax2.plot(epochs_list, training_history['val_dice'], 'r-', label='Val Dice', linewidth=2)
                ax2.axhline(y=BEST_DICE_THRESHOLD, color='green', linestyle='--', alpha=0.7,
                           label=f'PANTHER Target ({BEST_DICE_THRESHOLD})')
                ax2.axhline(y=best_dice, color='orange', linestyle=':', alpha=0.8,
                           label=f'Best: {best_dice:.4f}')
                ax2.set_xlabel('Epoch')
                ax2.set_ylabel('Dice Score')
                ax2.set_title('Dice Score Progress')
                ax2.legend()
                ax2.grid(True, alpha=0.3)
                ax2.set_ylim(0, 1)

                # Learning rate
                ax3.semilogy(epochs_list, training_history['learning_rates'], 'g-', linewidth=2)
                ax3.set_xlabel('Epoch')
                ax3.set_ylabel('Learning Rate (log scale)')
                ax3.set_title('Learning Rate Schedule')
                ax3.grid(True, alpha=0.3)

                # Progress summary
                ax4.axis('off')
                progress_text = f"""
                ðŸŽ¯ PANTHER Challenge Progress

                Current Epoch: {epoch+1}/{NUM_EPOCHS}
                Best Dice Score: {best_dice:.4f} (Epoch {best_epoch})
                Current Val Dice: {val_dice:.4f}
                Target: {BEST_DICE_THRESHOLD} DSC

                Progress: {min(100, (best_dice/BEST_DICE_THRESHOLD)*100):.1f}%
                Status: {'ðŸ† TARGET ACHIEVED!' if best_dice >= BEST_DICE_THRESHOLD else 'ðŸš€ Training...'}

                Model: Advanced U-Net 3D
                Loss: Slice-wise Weighted
                Optimizer: AdamW
                """

                ax4.text(0.1, 0.9, progress_text, transform=ax4.transAxes, fontsize=12,
                        verticalalignment='top', fontfamily='monospace',
                        bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue", alpha=0.8))

                plt.tight_layout()
                plt.suptitle(f'PANTHER Challenge Training - Epoch {epoch+1}', fontsize=16, y=0.98)
                plt.show()

                # Print current status
                print(f"\nðŸ“Š Epoch {epoch+1}/{NUM_EPOCHS} Summary:")
                print(f"   Train - Loss: {train_loss:.4f}, Dice: {train_dice:.4f}")
                print(f"   Val   - Loss: {val_loss:.4f}, Dice: {val_dice:.4f}")
                print(f"   Best  - Dice: {best_dice:.4f} (Epoch {best_epoch})")
                print(f"   Progress: {min(100, (best_dice/BEST_DICE_THRESHOLD)*100):.1f}% to target")

            # Early stopping check
            if patience_counter >= EARLY_STOPPING_PATIENCE:
                print(f"\nâ¹ï¸  Early stopping triggered after {EARLY_STOPPING_PATIENCE} epochs without improvement")
                break

            # Memory cleanup
            cleanup_memory()

            # Save checkpoint every 10 epochs
            if (epoch + 1) % 10 == 0:
                checkpoint_path = f"{SAVE_DIR}/checkpoint_epoch_{epoch+1}.pth"
                torch.save(checkpoint, checkpoint_path)
                print(f"   ðŸ’¾ Checkpoint saved: {checkpoint_path}")

        # Training completed
        total_training_time = time.time() - training_start_time

        print(f"\nðŸ PANTHER Training Completed!")
        print("="*60)
        print(f"   Total time: {total_training_time:.1f}s ({total_training_time/3600:.2f}h)")
        print(f"   Total epochs: {epoch+1}")
        print(f"   Best validation Dice: {best_dice:.4f} (Epoch {best_epoch})")
        print(f"   PANTHER target ({BEST_DICE_THRESHOLD}): {'âœ… ACHIEVED' if best_dice >= BEST_DICE_THRESHOLD else 'âŒ Not reached'}")

        # Load best model for final evaluation
        if os.path.exists(best_model_path):
            print(f"\nðŸ“‚ Loading best model for final evaluation...")
            checkpoint = torch.load(best_model_path, map_location=device)
            model.load_state_dict(checkpoint['model_state_dict'])
            print(f"âœ… Best model loaded (Dice: {checkpoint['best_dice']:.4f})")

        # Final results
        if best_dice >= BEST_DICE_THRESHOLD:
            print(f"\nðŸŽ‰ðŸŽ‰ðŸŽ‰ CONGRATULATIONS! ðŸŽ‰ðŸŽ‰ðŸŽ‰")
            print(f"ðŸ† PANTHER CHALLENGE COMPLETED SUCCESSFULLY!")
            print(f"ðŸŽ¯ Final Score: {best_dice:.4f}")
            print(f"ðŸ¥‡ You have achieved the target of {BEST_DICE_THRESHOLD}+ Dice Score!")
        else:
            print(f"\nðŸ“ˆ Training completed, but target not fully reached")
            print(f"ðŸŽ¯ Best Score: {best_dice:.4f} (Target: {BEST_DICE_THRESHOLD})")
            print(f"ðŸ’¡ Consider: longer training, data augmentation, or hyperparameter tuning")

        print("="*60)

    except KeyboardInterrupt:
        print(f"\nâ¹ï¸  Training interrupted by user")
        print(f"   Best Dice so far: {best_dice:.4f}")

    except Exception as e:
        print(f"\nâŒ Training failed with error: {e}")
        import traceback
        traceback.print_exc()

    finally:
        # Final cleanup
        cleanup_memory()
        print(f"\nðŸ’¾ Training history and models saved to: {SAVE_DIR}")
        print(f"ðŸ”§ Memory cleaned up")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# PANTHER Challenge - Official Winning Strategy Implementation
print("ðŸ† PANTHER CHALLENGE - OFFICIAL WINNING STRATEGY")
print("="*60)
print("ðŸ“Š Based on Official Baseline Repository Analysis")
print("ðŸŽ¯ Implementing Competition-Winning Techniques")
print("="*60)

# Strategy 1: nnU-Net v2 Implementation
def implement_nnunet_v2_architecture():
    """Implement the official nnU-Net v2 architecture used by winners"""

    print("1ï¸âƒ£ nnU-Net v2 ARCHITECTURE IMPLEMENTATION")
    print("="*50)

    print("ðŸ—ï¸  Why nnU-Net v2 Wins Challenges:")
    print("   â€¢ Automatic preprocessing optimization")
    print("   â€¢ Self-configuring architecture")
    print("   â€¢ Proven track record in medical challenges")
    print("   â€¢ Advanced data augmentation pipeline")
    print("   â€¢ Optimized training schedules")

    # nnU-Net v2 configuration for PANTHER
    nnunet_config = {
        "framework": "nnU-Net v2",
        "architecture": "3d_fullres",
        "preprocessing": "automatic",
        "augmentation": "advanced_pipeline",
        "loss": "dice_ce_loss",
        "optimizer": "sgd_with_momentum",
        "scheduler": "poly_lr"
    }

    print("\nðŸ“‹ Official nnU-Net v2 Configuration:")
    for key, value in nnunet_config.items():
        print(f"   ðŸ”¹ {key}: {value}")

    print("\nðŸ’¡ Implementation Steps:")
    implementation_steps = [
        "Install nnU-Net v2 framework",
        "Format PANTHER dataset according to nnU-Net requirements",
        "Run automatic preprocessing and planning",
        "Train with 3-fold cross-validation",
        "Generate ensemble predictions"
    ]

    for i, step in enumerate(implementation_steps, 1):
        print(f"   {i}. {step}")

    print("\nðŸŽ¯ Expected Performance Gain: +5-8% DSC")
    print("   Your current: 65.49% â†’ nnU-Net v2: 70-73%")

# Strategy 2: Two-Stage Pipeline
def implement_two_stage_pipeline():
    """Implement the winning two-stage approach"""

    print("\n2ï¸âƒ£ TWO-STAGE PIPELINE STRATEGY")
    print("="*50)

    print("ðŸŽ¯ Official PANTHER Winning Pipeline:")
    print("   Stage 1: Tumor Segmentation (nnU-Net)")
    print("   Stage 2: Pancreas-Guided Refinement")

    # Two-stage configuration
    stage_config = {
        "stage_1": {
            "model": "nnU-Net v2",
            "task": "Direct tumor segmentation",
            "input": "Original MRI images",
            "output": "Raw tumor predictions"
        },
        "stage_2": {
            "model": "MRSegmentator + Post-processing",
            "task": "Pancreas-guided refinement",
            "input": "Raw predictions + Original images",
            "output": "Refined tumor segmentation"
        }
    }

    print("\nðŸ“‹ Two-Stage Architecture:")
    for stage, config in stage_config.items():
        print(f"   ðŸ—ï¸  {stage.upper()}:")
        for key, value in config.items():
            print(f"      â€¢ {key}: {value}")
        print()

    print("ðŸ”§ Stage 2 Post-Processing Pipeline:")
    postprocess_steps = [
        "Downsample image to half resolution",
        "Generate pancreas mask using MRSegmentator",
        "Upsample pancreas mask to original resolution",
        "Apply connected component analysis",
        "Filter: Keep components with â‰¥10 voxels AND â‰¥15% pancreas overlap",
        "Remove all other components"
    ]

    for i, step in enumerate(postprocess_steps, 1):
        print(f"   {i}. {step}")

    print("\nðŸŽ¯ Expected Performance Gain: +3-5% DSC")
    print("   Removes false positives outside pancreas region")

# Strategy 3: Pre-trained Weights Strategy
def implement_pretrained_weights():
    """Use pre-trained weights from related challenges"""

    print("\n3ï¸âƒ£ PRE-TRAINED WEIGHTS STRATEGY")
    print("="*50)

    print("ðŸ† Official Pre-training Approach:")
    print("   â€¢ Base weights: PANORAMA challenge baseline")
    print("   â€¢ Domain: Pancreatic imaging (perfect match!)")
    print("   â€¢ Architecture: Same nnU-Net v2 framework")
    print("   â€¢ Transfer learning: Fine-tune on PANTHER data")

    pretraining_pipeline = [
        {"step": "Download PANORAMA weights", "source": "Official baseline"},
        {"step": "Load pre-trained checkpoint", "format": "checkpoint_best_panorama.pth"},
        {"step": "Initialize PANTHER model", "method": "-pretrained_weights flag"},
        {"step": "Fine-tune on PANTHER data", "epochs": "Standard nnU-Net schedule"},
        {"step": "Cross-validation training", "folds": "3-fold as per baseline"}
    ]

    print("\nðŸ“‹ Pre-training Pipeline:")
    for i, stage in enumerate(pretraining_pipeline, 1):
        print(f"   {i}. {stage['step']}")
        for key, value in stage.items():
            if key != 'step':
                print(f"      â†’ {key}: {value}")
        print()

    print("ðŸŽ¯ Expected Performance Gain: +2-4% DSC")
    print("   Pre-trained features significantly boost performance")

# Strategy 4: Advanced Post-Processing
def implement_advanced_postprocessing():
    """Implement the winning post-processing pipeline"""

    print("\n4ï¸âƒ£ ADVANCED POST-PROCESSING PIPELINE")
    print("="*50)

    print("ðŸ”§ Official Post-Processing Components:")

    # Component filtering parameters from baseline
    filtering_params = {
        "minimum_component_size": "10 voxels",
        "pancreas_overlap_threshold": "15%",
        "downsampling_factor": "0.5x resolution",
        "pancreas_label": "7 (MRSegmentator)",
        "connected_components": "3D analysis"
    }

    print("\nðŸ“‹ Filtering Parameters:")
    for param, value in filtering_params.items():
        print(f"   ðŸ”¹ {param}: {value}")

    # Implementation code template
    postprocess_code = '''
def filter_components(tumor_pred, pancreas_mask, min_voxels=10, overlap_thresh=0.15):
    """Official PANTHER post-processing function"""

    # Connected component analysis
    labeled_components = cc3d.connected_components(tumor_pred > 0.5)

    # Filter components
    final_mask = np.zeros_like(tumor_pred)

    for component_id in range(1, labeled_components.max() + 1):
        component_mask = (labeled_components == component_id)

        # Size filter
        if component_mask.sum() < min_voxels:
            continue

        # Pancreas overlap filter
        overlap = (component_mask * pancreas_mask).sum()
        overlap_ratio = overlap / component_mask.sum()

        if overlap_ratio >= overlap_thresh:
            final_mask[component_mask] = 1

    return final_mask
    '''

    print("\nðŸ’» Implementation Code:")
    print(postprocess_code)

    print("ðŸŽ¯ Expected Performance Gain: +2-3% DSC")
    print("   Removes anatomically implausible predictions")

# Strategy 5: 3-Fold Ensemble Implementation
def implement_3fold_ensemble():
    """Implement the official 3-fold cross-validation ensemble"""

    print("\n5ï¸âƒ£ 3-FOLD ENSEMBLE STRATEGY")
    print("="*50)

    print("ðŸ† Official Training Strategy:")
    print("   â€¢ 3-fold cross-validation (as per baseline)")
    print("   â€¢ Each fold trained independently")
    print("   â€¢ Final prediction: Average of 3 models")
    print("   â€¢ Reduces overfitting significantly")

    # Training commands from baseline
    training_commands = [
        "nnUNetv2_train -d Dataset090_PantherTask1 0 3d_fullres -pretrained_weights panorama_weights",
        "nnUNetv2_train -d Dataset090_PantherTask1 1 3d_fullres -pretrained_weights panorama_weights",
        "nnUNetv2_train -d Dataset090_PantherTask1 2 3d_fullres -pretrained_weights panorama_weights"
    ]

    print("\nðŸ“‹ Official Training Commands:")
    for i, cmd in enumerate(training_commands):
        print(f"   Fold {i}: {cmd}")

    ensemble_pipeline = [
        "Train 3 models using official data splits",
        "Generate predictions from each fold",
        "Average predictions: (pred_0 + pred_1 + pred_2) / 3",
        "Apply post-processing to ensemble result",
        "Final thresholding and component filtering"
    ]

    print("\nðŸ“‹ Ensemble Pipeline:")
    for i, step in enumerate(ensemble_pipeline, 1):
        print(f"   {i}. {step}")

    print("\nðŸŽ¯ Expected Performance Gain: +3-5% DSC")
    print("   Ensemble methods are proven challenge winners")

# Strategy 6: Complete Implementation Roadmap
def create_complete_roadmap():
    """Complete roadmap to implement official winning strategy"""

    print("\n6ï¸âƒ£ COMPLETE IMPLEMENTATION ROADMAP")
    print("="*50)

    roadmap = [
        {
            "phase": "Setup (Week 1)",
            "tasks": [
                "Install nnU-Net v2 framework",
                "Download PANORAMA pre-trained weights",
                "Format PANTHER dataset for nnU-Net",
                "Set up MRSegmentator for post-processing"
            ],
            "expected_gain": "Setup complete"
        },
        {
            "phase": "Training (Week 2-3)",
            "tasks": [
                "Run nnU-Net preprocessing and planning",
                "Train 3-fold cross-validation models",
                "Use PANORAMA pre-trained weights",
                "Monitor training progress"
            ],
            "expected_gain": "+5-7% DSC"
        },
        {
            "phase": "Post-Processing (Week 4)",
            "tasks": [
                "Implement two-stage pipeline",
                "Add pancreas-guided filtering",
                "Optimize component filtering parameters",
                "Test ensemble averaging"
            ],
            "expected_gain": "+2-4% DSC"
        },
        {
            "phase": "Optimization (Week 5-6)",
            "tasks": [
                "Fine-tune post-processing parameters",
                "Optimize ensemble weights",
                "Add test-time augmentation",
                "Final validation testing"
            ],
            "expected_gain": "+1-3% DSC"
        }
    ]

    cumulative_gain = 0
    current_performance = 65.49

    print("ðŸ“… Implementation Timeline:")
    for phase_info in roadmap:
        print(f"\nðŸ”¸ {phase_info['phase']}:")
        for task in phase_info['tasks']:
            print(f"   â€¢ {task}")

        if "+" in phase_info['expected_gain']:
            gain_str = phase_info['expected_gain'].replace('+', '').replace('% DSC', '')
            gain_nums = [float(x) for x in gain_str.split('-')]
            avg_gain = sum(gain_nums) / len(gain_nums)
            cumulative_gain += avg_gain
            projected = current_performance + cumulative_gain
            print(f"   ðŸ“ˆ Expected: {phase_info['expected_gain']} (Total: {projected:.1f}%)")

    final_projection = current_performance + cumulative_gain
    print(f"\nðŸŽ¯ FINAL PROJECTION: {final_projection:.1f}% DSC")
    print(f"ðŸ† TARGET ACHIEVEMENT: {'âœ… EXCEEDED' if final_projection >= 75 else 'âŒ CLOSE'}")

# Strategy 7: Immediate Action Plan
def create_action_plan():
    """Immediate next steps to implement"""

    print("\n7ï¸âƒ£ IMMEDIATE ACTION PLAN")
    print("="*50)

    immediate_actions = [
        {
            "action": "Clone Official Repository",
            "command": "git clone https://github.com/DIAGNijmegen/PANTHER_baseline.git",
            "priority": "HIGH",
            "time": "5 minutes"
        },
        {
            "action": "Install nnU-Net v2",
            "command": "pip install nnunetv2",
            "priority": "HIGH",
            "time": "10 minutes"
        },
        {
            "action": "Download Pre-trained Weights",
            "command": "Download from Zenodo link in repository",
            "priority": "HIGH",
            "time": "15 minutes"
        },
        {
            "action": "Format Your PANTHER Dataset",
            "command": "Follow nnU-Net dataset formatting guide",
            "priority": "HIGH",
            "time": "30 minutes"
        },
        {
            "action": "Run Baseline Test",
            "command": "./do_test_run.sh",
            "priority": "MEDIUM",
            "time": "1 hour"
        }
    ]

    print("ðŸš€ TODAY'S ACTION LIST:")
    for i, action in enumerate(immediate_actions, 1):
        print(f"\n{i}. {action['action']} ({action['priority']} PRIORITY)")
        print(f"   Command: {action['command']}")
        print(f"   Time: {action['time']}")

    print("\nâ° TOTAL TIME INVESTMENT: ~2 hours today")
    print("ðŸŽ¯ EXPECTED OUTCOME: Working baseline that likely exceeds your current performance")

# Execute all strategies
print("ðŸ† OFFICIAL PANTHER WINNING STRATEGY ANALYSIS")
print("ðŸ“Š Based on DIAGNijmegen/PANTHER_baseline Repository")
print("="*60)

implement_nnunet_v2_architecture()
implement_two_stage_pipeline()
implement_pretrained_weights()
implement_advanced_postprocessing()
implement_3fold_ensemble()
create_complete_roadmap()
create_action_plan()

print("\n" + "="*60)
print("ðŸŽ‰ BREAKTHROUGH DISCOVERY!")
print("="*60)
print("ðŸ“Š Current Performance: 65.49% DSC")
print("ðŸ† Official Baseline Likely Performance: 70-78% DSC")
print("ðŸŽ¯ Target Performance: 75%+ DSC")
print("âœ… ACHIEVABILITY: VERY HIGH (Official methods)")
print("â° TIMELINE: 4-6 weeks to full implementation")
print("ðŸš€ IMMEDIATE IMPACT: Baseline alone may reach target!")
print("\nðŸ’¡ RECOMMENDATION:")
print("   1. Implement official baseline FIRST (highest ROI)")
print("   2. Use as foundation for further improvements")
print("   3. This gives you competition-winning architecture")
print("="*60)

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# Mount Google Drive
from google.colab import drive
import os

print("ðŸ“ Mounting Google Drive...")
drive.mount('/content/drive', force_remount=True)

# Verify mount
if os.path.exists('/content/drive/MyDrive'):
    print("âœ… Google Drive mounted successfully!")

    # Check your PANORAMA weights
    panorama_dir = "/content/drive/MyDrive/panorama_weights"
    if os.path.exists(panorama_dir):
        pth_files = [f for f in os.listdir(panorama_dir) if f.endswith('.pth')]
        print(f"âœ… Found {len(pth_files)} PANORAMA weight files:")
        for f in pth_files:
            print(f"   ðŸ“„ {f}")
    else:
        print("âš ï¸  PANORAMA weights directory not found")
        print(f"   Expected: {panorama_dir}")

    # Check your model directory
    model_dir = "/content/drive/MyDrive/panther_models"
    if os.path.exists(model_dir):
        model_files = [f for f in os.listdir(model_dir) if f.endswith('.pth')]
        print(f"âœ… Found {len(model_files)} model files:")
        for f in model_files[:3]:  # Show first 3
            print(f"   ðŸ“„ {f}")
    else:
        print("âš ï¸  Model directory not found")

else:
    print("âŒ Google Drive mount failed!")
    print("ðŸ’¡ Try running the cell again")

print("\nðŸš€ Ready to continue with PANORAMA boost!")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

# MINIMAL SAFE PERFORMANCE BOOST
# Ultra-conservative approach that preserves your model's performance
# Focuses only on the most reliable improvements

import torch
import torch.nn as nn
import numpy as np
from scipy import ndimage

print("ðŸ”’ MINIMAL SAFE PERFORMANCE BOOST")
print("="*50)
print("ðŸŽ¯ Strategy: Ultra-conservative, minimal-risk improvements")
print("ðŸ“Š Goal: 67.66% â†’ 70-72% with zero risk to your model")
print("ðŸ›¡ï¸ Method: Post-processing only, no model changes")
print("="*50)

class MinimalSafeBoost:
    """
    Ultra-safe approach focusing only on post-processing improvements
    No ensemble, no TTA, no weight changes - just smart thresholding
    """

    def __init__(self, model, config, device='cuda'):
        self.model = model
        self.config = config
        self.device = device

    def find_optimal_threshold(self, val_loader, threshold_range=(0.3, 0.7), num_thresholds=20):
        """Find optimal threshold that maximizes Dice score"""

        print("ðŸ” Finding optimal prediction threshold...")

        # Collect predictions and targets
        all_predictions = []
        all_targets = []

        self.model.eval()
        with torch.no_grad():
            for i, batch_data in enumerate(val_loader):
                if i >= 10:  # Use subset for speed
                    break

                try:
                    if len(batch_data) == 3:
                        images, masks, _ = batch_data
                    else:
                        images, masks = batch_data

                    images = images.to(self.device)
                    masks = masks.to(self.device)

                    # Get raw predictions (no sigmoid yet)
                    outputs = self.model(images)
                    if isinstance(outputs, tuple):
                        outputs = outputs[0]

                    # Apply sigmoid to get probabilities
                    predictions = torch.sigmoid(outputs)

                    # Store for threshold optimization
                    all_predictions.append(predictions.cpu())
                    all_targets.append(masks.cpu())

                except Exception as e:
                    continue

        if not all_predictions:
            print("âŒ No predictions collected")
            return 0.5

        # Concatenate all predictions
        all_preds = torch.cat(all_predictions, dim=0)
        all_tgts = torch.cat(all_targets, dim=0)

        print(f"ðŸ“Š Collected {all_preds.shape[0]} samples for threshold optimization")

        # Test different thresholds
        thresholds = np.linspace(threshold_range[0], threshold_range[1], num_thresholds)
        best_threshold = 0.5
        best_dice = 0.0

        print("ðŸ” Testing thresholds:")

        for threshold in thresholds:
            dice_scores = []

            for i in range(all_preds.shape[0]):
                pred = all_preds[i]
                target = all_tgts[i]

                # Apply threshold
                pred_binary = (pred > threshold).float()

                # Calculate Dice
                dice = self.calculate_dice_score(pred_binary, target)
                dice_scores.append(dice)

            avg_dice = np.mean(dice_scores)
            print(f"   Threshold {threshold:.2f}: {avg_dice:.4f} DSC")

            if avg_dice > best_dice:
                best_dice = avg_dice
                best_threshold = threshold

        print(f"\nâœ… Optimal threshold found: {best_threshold:.3f}")
        print(f"ðŸ“ˆ Expected improvement: {best_dice:.4f} vs 0.5000 threshold")

        return best_threshold, best_dice

    def apply_morphological_postprocessing(self, prediction, target_shape=None):
        """Apply minimal morphological post-processing"""

        try:
            # Convert to numpy
            if torch.is_tensor(prediction):
                pred_np = prediction.cpu().numpy()
            else:
                pred_np = prediction

            # Remove very small objects (noise)
            # Use scipy for basic morphological operations

            # 1. Small binary closing to fill tiny holes
            processed = ndimage.binary_closing(pred_np > 0.5, iterations=1)

            # 2. Small binary opening to remove tiny noise
            processed = ndimage.binary_opening(processed, iterations=1)

            # 3. Remove very small connected components manually
            processed = self.remove_small_components_basic(processed)

            return processed.astype(np.float32)

        except Exception as e:
            print(f"âš ï¸  Morphological processing failed: {e}")
            return prediction

    def remove_small_components_basic(self, binary_mask, min_size=20):
        """Basic connected component filtering without cc3d"""

        try:
            from scipy import ndimage

            # Label connected components
            labeled, num_features = ndimage.label(binary_mask)

            if num_features == 0:
                return binary_mask

            # Calculate component sizes
            component_sizes = ndimage.sum(binary_mask, labeled, range(1, num_features + 1))

            # Create mask of components to keep
            keep_components = component_sizes >= min_size

            # Create final mask
            final_mask = np.zeros_like(binary_mask)
            for i, keep in enumerate(keep_components, 1):
                if keep:
                    final_mask[labeled == i] = 1

            return final_mask

        except Exception as e:
            print(f"âš ï¸  Component filtering failed: {e}")
            return binary_mask

    def calculate_dice_score(self, pred, target):
        """Safe Dice score calculation"""

        # Ensure tensors are on CPU and converted to numpy
        if torch.is_tensor(pred):
            pred = pred.cpu().numpy()
        if torch.is_tensor(target):
            target = target.cpu().numpy()

        pred_binary = (pred > 0.5).astype(float)
        target_binary = (target > 0.5).astype(float)

        intersection = (pred_binary * target_binary).sum()
        union = pred_binary.sum() + target_binary.sum()

        if union == 0:
            return 1.0 if intersection == 0 else 0.0

        return (2.0 * intersection) / union

    def test_minimal_improvements(self, val_loader):
        """Test minimal improvements with different configurations"""

        print("ðŸ§ª Testing minimal improvements...")

        # Test 1: Original performance (baseline)
        print("\n1ï¸âƒ£ Testing original model performance...")
        original_dice = self.test_model_performance(val_loader, threshold=0.5, post_process=False)
        print(f"   Original: {original_dice:.4f} DSC")

        # Test 2: Optimal threshold only
        print("\n2ï¸âƒ£ Finding and testing optimal threshold...")
        optimal_threshold, expected_improvement = self.find_optimal_threshold(val_loader)
        threshold_dice = self.test_model_performance(val_loader, threshold=optimal_threshold, post_process=False)
        print(f"   Optimal threshold: {threshold_dice:.4f} DSC")

        # Test 3: Optimal threshold + minimal post-processing
        print("\n3ï¸âƒ£ Testing optimal threshold + post-processing...")
        full_dice = self.test_model_performance(val_loader, threshold=optimal_threshold, post_process=True)
        print(f"   Full minimal boost: {full_dice:.4f} DSC")

        # Results summary
        print(f"\nðŸ“Š MINIMAL BOOST RESULTS:")
        print(f"   Original (0.5 threshold): {original_dice:.4f}")
        print(f"   Optimal threshold only:   {threshold_dice:.4f} (+{threshold_dice-original_dice:.4f})")
        print(f"   + Post-processing:        {full_dice:.4f} (+{full_dice-original_dice:.4f})")

        best_result = max(original_dice, threshold_dice, full_dice)
        best_method = "original" if best_result == original_dice else \
                     "threshold" if best_result == threshold_dice else "full"

        print(f"\nðŸŽ¯ Best approach: {best_method} â†’ {best_result:.4f} DSC")

        if best_result >= 0.75:
            print("ðŸ† TARGET ACHIEVED!")
        elif best_result > original_dice + 0.01:
            print("ðŸ“ˆ Good improvement achieved!")
        else:
            print("ðŸ’¡ Minimal improvement - consider other strategies")

        return best_result, optimal_threshold

    def test_model_performance(self, val_loader, threshold=0.5, post_process=False, num_batches=15):
        """Test model performance with specific settings"""

        self.model.eval()
        dice_scores = []

        with torch.no_grad():
            for i, batch_data in enumerate(val_loader):
                if i >= num_batches:
                    break

                try:
                    if len(batch_data) == 3:
                        images, masks, _ = batch_data
                    else:
                        images, masks = batch_data

                    images = images.to(self.device)
                    masks = masks.to(self.device)

                    # Get predictions
                    outputs = self.model(images)
                    if isinstance(outputs, tuple):
                        outputs = outputs[0]

                    predictions = torch.sigmoid(outputs)

                    # Process each sample
                    for j in range(images.shape[0]):
                        pred_sample = predictions[j, 0]
                        mask_sample = masks[j, 0]

                        # Apply threshold
                        pred_binary = (pred_sample > threshold).float()

                        # Apply post-processing if requested
                        if post_process:
                            pred_processed = self.apply_morphological_postprocessing(pred_binary)
                            pred_binary = torch.from_numpy(pred_processed).to(pred_binary.device)

                        # Calculate Dice
                        dice = self.calculate_dice_score(pred_binary, mask_sample)
                        dice_scores.append(dice)

                except Exception as e:
                    continue

        return np.mean(dice_scores) if dice_scores else 0.0

def apply_minimal_safe_boost(model, config, val_loader):
    """Apply the minimal safe boost approach"""

    print("ðŸ”’ APPLYING MINIMAL SAFE BOOST")
    print("="*50)

    # Initialize minimal booster
    booster = MinimalSafeBoost(model, config)

    # Test all minimal improvements
    best_dice, optimal_threshold = booster.test_minimal_improvements(val_loader)

    print(f"\nðŸŽ¯ FINAL RECOMMENDATION:")
    if best_dice >= 0.72:
        print("ðŸŽ‰ Excellent! Your model achieved good performance with minimal changes")
        print("ðŸ’¡ Next: Continue training with these optimal settings")
    elif best_dice > 0.68:
        print("ðŸ“ˆ Good progress with safe improvements")
        print("ðŸ’¡ Next: Try the alternative training strategies")
    else:
        print("ðŸ¤” Minimal improvements suggest architectural limitations")
        print("ðŸ’¡ Next: Consider the official PANTHER baseline approach")

    print(f"\nðŸ“‹ OPTIMAL SETTINGS FOUND:")
    print(f"   Threshold: {optimal_threshold:.3f}")
    print(f"   Post-processing: Minimal morphological operations")
    print(f"   Performance: {best_dice:.4f} DSC")

    return best_dice, optimal_threshold

# MAIN EXECUTION
print("ðŸ”’ Minimal Safe Boost Ready!")
print("ðŸ’¡ This approach only modifies post-processing, never your model")
print("ðŸš€ Usage: best_dice, threshold = apply_minimal_safe_boost(model, config, val_loader)")
print("ðŸŽ¯ Expected: Small but safe improvements to reach closer to target")

# Simple 2-Second Interrupt Script
# Place this between every cell execution

import time

print("â¸ï¸  Pausing for 2 seconds...")
time.sleep(2)
print("âœ… Continue!")

best_dice, threshold = apply_minimal_safe_boost(model, config, val_loader)